[
  {
    "content": "In a modern web app, the application server implements a Web API that provides service to the front-end JavaScript code.\nA Web API is a defined set of HTTP request messages along with a definition of the structure of response messages, usually expressed in JSON format (from Wikipedia).\nA Web API provides service to clients through several endpoints. Each endpoint is named with an URL, e.g. http://example.com/products. A client uses an appropriate HTTP verb to invoke the endpoint.There are a few common paradigms to design Web APIs and structure the endpoints. We’ll discuss two, namely REST and RPC, in the next two sections. We’ll use REST style in the examples here. However, the focus on this section is the payload in requests and responses.\nThe two most popular payload formats in Web APIs are URL-encoded and JSON. URL encoded payloads are key-value pairs, and are only suitable for simple values. JSON is more flexible in representing data structure.\n    URL-encoded JSON     Structure key value pairs similar to JavaScript objects   Content type application/x-www-form-urlencoded application/json   In GET requests as query of the URL no   In other requests (POST, PUT, etc) in body in body   In responses in body in body    URL-encoded payload ‘URL-encoded’ was one of the original encoding in the Web to encode form data that a \u003cform\u003e submits to a server. (We’ve discussed this in Chapter 1.) You can use URL-encoded in all kinds of requests and responses.\nFor example, below is a simple (RPC style) request to get information about product with id=5.\nGET /products.info?id=5 HTTP/1.1 Host: example.com  Notice that GET requests cannot have message body. Therefore, the URL-encoded payload must be packed in the URL.\n The response for the above request could be the following.\nHTTP/1.1 200 Ok Content-type: application/x-www-form-urlencoded Content-length: 79 id=5\u0026productName=Coke+candy\u0026category=Confections\u0026unitPrice=10.5\u0026unitsInStock=20 URL-encoded payload are also common as body of other kinds of requests (e.g. POST, PUT). Below is a sample (RPC style) request to create a new product.\nPOST /products.create HTTP/1.1 Host: example.com Content-type: application/x-www-form-urlencoded Content-length: 53 productName=Great+new+chocolate\u0026category=Confections\u0026unitPrice=20\u0026unitsInStock=100 JSON, JavaScript Object Notation The JSON data format is a textual language-agnostic data exchange format. JSON is supported by many popular languages, including Java, Python, and, of course, JavaScript.\nBelow is a sample response message that returns information about the product with id=5.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 116 { \"id\": 5, \"productName\": \"Coke candy\", \"category\": \"Confections\", \"unitPrice\": 10.5, \"unitsInStock\": 20 } The syntax of JSON is similar to JavaScript object, array, numbers, string and boolean. But there are several differences.\n string values must use double quotation marks, e.g. \"correct\", not 'incorrect'. keys of objects must be quoted strings, e.g. {\"name\": \"peter\", \"age\": 20}, not {name: \"peter\", 'age': 20} there is only one root value. To represent a list of value, you can use array, e.g. [1,2,3]. Simple values (namely numbers, strings, true, false, null) are supported, but JSON data cannot include functions. Comments /* like this */ are not allowed in JSON.  Object-enclosed JSON Although simple values like 123, \"json sample\", true are valid JSON data, in many Web APIs, the returned values in responses are object-enclosed. In other words, the root value in the JSON data is an object. Below are two possible designs for returning data about two products in JSON, e.g. in response to a search request. (We omit some fields about products for brevity.) The first design returns the items directly in an array.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 131 [ { \"id\": 5, \"productName\": \"Coke candy\", \"unitPrice\": 10.5 }, { \"id\": 6, \"productName\": \"Chocolate bar\", \"unitPrice\": 25.0 } ] The second design encloses the data in an object. Usually, the items are described under a property of the object, and there is another property to provide the number of items (e.g. count).\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 166 { \"count\": 2, \"items\": [ { \"id\": 5, \"productName\": \"Coke candy\", \"unitPrice\": 10.5 }, { \"id\": 6, \"productName\": \"Chocolate bar\", \"unitPrice\": 25.0 } ] } JSON payload in requests GET requests cannot take message body. Because JSON payload is usually large and may exceed the maximum allowable length of URL, we do not use JSON payload in GET requests.\nOn the other hand, JSON payload can appear in the message body of non-GET requests (e.g. POST, PUT, DELETE) For example, to create a product, the client may send the following (RPC style) request.\nPOST /products.create HTTP/1.1 Host: example.com Content-type: application/json Content-length: 104 { \"productName\": \"New candy\", \"category\": \"Confections\", \"unitPrice\": 8.6, \"unitsInStock\": 500 } JavaScript support for JSON Two built-in functions in JavaScript support conversion between JavaScript values and JSON data.\nJSON.stringify() (online ref) converts a JavaScript value into a JSON string.\nlet product5 = { productName: 'New candy', category: \"Confections\", unitPrice: 8.6, unitsInStock: 500 }; console.log(product5); let jsonString = JSON.stringify(product5); console.log(jsonString); JSON.parse() (online ref) converts a JSON string back into a JavaScript value.\n// a JSON string obtained from a Web API const jsonString = '{\"id\":10248,\"customerId\":85,\"orderDate\":\"2012-07-04\",\"freight\":32.38,\"shipCity\":\"Reims\",\"lines\":[{\"productId\":11,\"unitPrice\":14,\"quantity\":12},{\"productId\":42,\"unitPrice\":9.8,\"quantity\":10},{\"productId\":72,\"unitPrice\":34.8,\"quantity\":5}]}'; let data = JSON.parse(jsonString); console.log(data); ",
    "description": "",
    "tags": null,
    "title": "5-1 Web API, concepts",
    "uri": "/5appserver/5-1/"
  },
  {
    "content": "This lab goes through the basics of the Node.js platform.\nQuick start Node.js (https://nodejs.org) is a platform built on Chrome’s JavaScript runtime V8 for easily building fast, scalable network applications. Node.js supports the same basic JavaScript programming language as web browsers. As the first example, let’s run the following program p101.mjs in both browser and Node. (Follow instruction to install Node.)\n// p101.mjs // return the largest number in an array // assume at least 1 entry, and all entries are numbers function largest (A) { let big=A[0]; for (let i=1; i\u003cA.length; i++) { if (big\u003cA[i]) big=A[i]; } return big; } let N = [ 3, 7, 6, 8, 2, 5 ]; console.log(`The largest is ${largest(N)}`);  We save JavaScript programs in files with extension *.mjs instead of *.js in this chapter. The extension informs Node.js that this file is a ES module, instead of the default of Common JS module. This allows us to use the modern syntax import to import modules. Instead of use the mjs extension, you can also set the default module type in the type attribute of the package.json config file.\n The JavaScript engine provides some common features in both Node and browsers:\n JavaScript language features: control flow, variables, data structure, defining class, functions, regular expression, etc Some global objects and functions:  console.log() timers: setInterval(), setTimeout() Date class: let now = new Date() JSON processing: JSON.parse(), JSON.stringify()    But Node misses some features specific to the browser platform, e.g.\n document tree (i.e. DOM tree)  a Node program generally does not involve an HTML document no interface and mouse or keyboard events   and other APIs in the Web API  Event loop in Node Similar to JavaScript runtime in browser, Node includes an event loop that handles events. The event loop continues until all events are handled and there are no future events. Some common cases that trigger events are:\n timer: when time is up, call a function file I/O, network I/O, etc: When some data is ready to read, or some I/O operations finish, the Node runtime triggers an event and call an event handler some objects can generate events system events, e.g. Ctrl-C interrupt  Trace the execution of the following program.\n// p102.mjs // countdown from 10 let N = 10; function tick() { if (N\u003c=0) { console.log('Time\\'s up!'); clearInterval(timer); } else { console.log(N); N--; } } // this starts the timer const timer = setInterval(tick, 1000); // event loop goes here ... At any time, Node runs at most 1 event handler. If there are no pending events, the event loop blocks and waits for any future events. If Node determines that there are no more future events, it quits.\nModules Node also support the new standard of JavaScript module known as ES module (online reference). This allows you to import new functionalities to the Node platform. The Node platform comes with some built-in modules (which are installed together with Node). See the online reference for a list of the built-in modules.\nMany modules in Node provide a default export, and usually the default export is an object that encapsulate functions or classes of the module. To import this kind of modules, use import variableName from 'moduleName'. This function returns an object that represents the module in your program. You can assign this to a variable of any convenient name.\nThe following example demonstrates how to use another built-in module os to find some basic hardware information of your computer.\n// p103.mjs // show basic info about CPU and memory import os from 'os'; let cpus = os.cpus(); console.log(`CPU: ${cpus[0].model}, ${cpus.length}core`); console.log(`Total memory: ${os.totalmem()/1024**3}G`); NPM modules Node.js comes with many built-in modules that cover various network services. But usually programmers take advantage of many high-quality third-party JavaScript libraries. These libraries are packed as packages, and Node.js used the built-in NPM command line tool to download and install packages.\nBy default, the NPM command line tool downloads packages from https://npmjs.com/, which is the largest registry of JavaScript packages. For example, the systeminformation package provides a lot more information than the Node built-in module os.\n// p104.mjs import si from 'systeminformation'; si.cpu() .then(data =\u003e console.log(data)); In order to run the above example, you have to first download the systeminformation module from npmjs.com with the following command. This command creates a folder ./node_modules and install downloaded packages locally in the current project.\n$ npm install systeminformation # or, a shorthand notation  $ npm i systeminformation After installing the package, you can now run example p104.mjs.\n$ node p104.mjs  As we mentioned in previous lectures, a Node project is a folder that contains the JavaScript programs, JavaScript libraries / modules and other assets (e.g. HTML, images) for an application.\n  Instead of installing packages locally in a project, you can also install packages globally with npm install -g packageName. However, we’ll not do this in this course.\n Package.json Remembering and installing the dependencies of a Node application manually is error-prone. Dependencies of an application refer to the packages that must be installed properly before this application and run successfully. Fortunately, Node.js already supports a configuration file at the root of an application project folder called package.json. Among other functionality, package.json contains a property dependencies that list the packages required by the application. Run this command to create a package.json at the current folder.\n$ npm init -y You’ll see the following data in the package.json generated.\n{ \"name\": \"chap4-1\", \"version\": \"1.0.0\", \"dependencies\": { \"systeminformation\": \"^5.9.2\" }, // other properties omitted for brevity } From now on, when you install more packages locally, it is assumed that the packages are new dependency of the current applicatoin, and npm will update package.json to include the dependency. For example, install the following package, and check the update in dependencies in package.json.\n$ npm install prompts When you pack your Node application for sharing (e.g. upload to npmjs.org), deployment (i.e. to run in production environment), or hand in your assignment, DON’T include the node_modules folder. There are several reasons.\n The folder usually contains a lot of files and occupy large disk space. When a user installs your application in their machine, they may want to use a more recent patch of some dependencies. Some packages include platform-specific binaries (e.g. libraries written in C).  With the dependencies listed in package.json, one can install them easily with the following command.\n$ npm install Semantic versioning In package.json, you might notice a version number after each mention of package.\n\"dependencies\": { \"prompts\": \"^2.4.1\", \"systeminformation\": \"^5.9.2\" }, This software versioning convention, called semantic versioning (online reference), is an important part of package management in Node / NPM. An explanation at the official page of https://semver.org/ is quoted below.\n Given a version number MAJOR.Minor.patch, increment the:\n MAJOR version when you make incompatible API changes, Minor version when you add functionality in a backwards compatible manner, and patch version when you make backwards compatible bug fixes.   Check the Version History of the systeminformation package and explain the meaning of version updates.\nThe dependencies section of package.json adds the symbol ^ before the version number. For version \u003e= 1.0.0, the caret range ^a.b.c means a version \u003e= the given version a.b.c, but smaller than a+1.0.0. For example, \"systeminformation\": \"^5.9.2\" means that, in the future, npm install can install the following versions of the package because they are considered as compatible with the application: 5.9.2, 5.9.3, 5.10.0, 5.10.1, 5.23.45. However, versions before 5.9.2 are not acceptable. (They may have less features, or they include a bug that has been fixed in 5.9.2. Moreover, version 6.x.y is not acceptable because they will introduce breaking changes. For other possibilities of specifying usable versions, refer to the online reference.\nDownloadable example The example source files are available here.\n",
    "description": "",
    "tags": null,
    "title": "4-1 Node.js primer",
    "uri": "/4server/4-1/"
  },
  {
    "content": "Document tree and DOM When a web browser loads an HTML page from a web server, it converts the HTML code into a tree data structure known as document tree. All user interactions in the client-side of a web app are done through this DOM tree.\nThe Document Object Model standard (online ref) defines a programming interface to access the document tree. Each HTML element is represented by a node in the tree. DOM defines the properties, methods and events for these nodes, and the nodes are accessible to JavaScript as objects. In summary, DOM defines how JavaScript code can access and manipulate nodes in a document tree.\nThe example p300-a.html shows some common tasks in a web app. In this app, the user enters two numbers in text input boxes, presses a button to calculate the sum, and displays the result inside the web page.\n document tree in JavaScript: document search a node using id of the element: let numA = document.getElementById('numA') each element is an object (with properties and methods) change a property of the node object: ans.innerText = 'something'  \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFirst example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cp\u003eThis example adds two numbers.\u003c/p\u003e \u003cp\u003ea: \u003cinput type=\"text\" id=\"numA\" value='3' /\u003e\u003c/p\u003e \u003cp\u003eb: \u003cinput type=\"text\" id=\"numB\" value='5' /\u003e\u003c/p\u003e \u003cp\u003e\u003cbutton type='button' id=\"btnAdd\"\u003eCalculate!\u003c/button\u003e\u003c/p\u003e \u003cp\u003ea+b = \u003cspan id=\"ans\"\u003e\u003c/span\u003e\u003c/p\u003e \u003c/div\u003e \u003c!-- embedded JavaScript program --\u003e \u003cscript\u003e const numA = document.getElementById('numA'); const numB = document.getElementById('numB'); const ans = document.getElementById('ans'); const btnAdd = document.getElementById('btnAdd'); btnAdd.addEventListener('click', function() { ans.innerHTML = parseFloat(numA.value) + parseFloat(numB.value) }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e MVVM and Vue The above example demonstrates document tree manipulation, a common style of programming during the early day of client-side programming. When some data changes, the program has to update different parts of the document tree. The programmer has to keep track of which parts of the document tree are affected by which piece of data.\nAlthough it can be facilitated with some higher level JavaScript library like jQuery, document tree manipulation does not scale well when web applications and their user interface become more complicated. In order to handle such complexity, web developers have adopted another approach known as MVVM (Model-view-viewmodel). Several popular JavaScript framework (e.g. React, AngularJS and Vue) implement MVVM (or a similar framework).\nIn this chapter, we’ll use Vue.js to illustrate the MVVM approach in client-side programming. The following example p300-b.html is a rewrite of p300-a.html using Vue.\n\u003cdiv id=\"app\"\u003e \u003cp\u003eThis example adds two numbers.\u003c/p\u003e \u003cp\u003ea: \u003cinput type=\"text\" v-model.number=\"a\" /\u003e\u003c/p\u003e \u003cp\u003eb: \u003cinput type=\"text\" v-model.number=\"b\" /\u003e\u003c/p\u003e \u003cp\u003e\u003cbutton type='button' @click=\"ans=a+b\" \u003eCalculate!\u003c/button\u003e\u003c/p\u003e \u003cp\u003ea+b = \u003cspan id=\"ans\"\u003e{{ ans }}\u003c/span\u003e\u003c/p\u003e \u003c/div\u003e \u003c!-- loading the Vue v3.2 JavaScript library from CDN --\u003e \u003cscript src=\"https://unpkg.com/vue@3.2\"\u003e\u003c/script\u003e \u003cscript\u003e const options = { data() { return { a: 3, b: 5, ans:3+5 } } }; const vm = Vue.createApp(options).mount('#app'); \u003c/script\u003e This example shows some differences in the Vue.js application:\n define a view model (the return value of data()), which is a JavaScript data structure that encapsulates the state of the current view in the web interface write a template to render the data in html (the HTML code at #app). Usually a html template contains placeholders that bind to some data property. When a data property changes value, Vue updates the view efficiently.  A note on loading JavaScript code We use the following HTML code to load the Vue library (which is a JavaScript file) from a CDN. You can also load a JavaScript file locally (from the same site as your web app). In case you use several third-party JavaScript libraries and/or develop complicated JavaScript code yourself, it is even better to use a JavaScript bundler to combine the JavaScript files into a few compressed files. This gives a faster load page.\n\u003cscript src=\"https://unpkg.com/vue@3.2\"\u003e\u003c/script\u003e After loading the Vue library, we can load our own code. You can save the code in a separate js file and load with a syntax similar to above. Alternatively, you can embed the code within a \u003cscript\u003e element, as in our example.\nWe embed JavaScript code in many of our example for sake of simplicity. However, in production code, it is generally recommended to remove JavaScript code from HTML file and move them to external JavaScript file.\n",
    "description": "",
    "tags": null,
    "title": "3-1 Background",
    "uri": "/3client/3-1/"
  },
  {
    "content": "This lab goes through the basic data types (Number and String) and control structures of the JavaScript programming language.\nNumber Two basic data types in JavaScript are Number and String. There are no separate types for integers and doubles. You define a variable x with let x. You don’t need to specify data type. (In some old code, you may also see definition of variables with var x. This is similar to let x, but allows you to redefine the variable. var is not recommended in new code in general.)\nlet a = 1; let b = 2e3; /* 2 * (10*10*10) */ let c; /* c is undefined */ c = a * 1.5 + b; console.log(c); You can also define constant with const x and assign an initial value. After definition, you cannot change the value of a constant. Also notice that this example shows that semicolon at end of line is optional.\nconst pi = 3.1415927 let radius // declare a variable radius = 4 // later, somehow the user inputs the value console.log('area =', pi * radius ** 2) In addition to the basic arithmetic operators (+, -, *, /, %) (ref), the Math built-in object (ref) provides some useful functions (e.g. Math.random(), Math.floor(), Math.ceil(), Math.round(), Math.pow(), Math.sqrt() and trigonometric functions.)\nlet r = 10 let area = Math.PI * r * r // same as Math.PI * Math.pow(r,2)  // a number from 1,2,3,4,5 and 6 // Math.random() returns a number between 0 and 1 let dice = Math.floor(Math.random()*6)+1 let x = Math.sin(Math.PI/2) // 1 let y = Math.sqrt(-1) // NaN Note: a recent update to the JavaScript language provides the new data type BigInt. BigInt can represent integer of arbitrary length. Please refer to this page for more information.\nString The other commonly used JavaScript data type is String. Strings can be delimited with single quote or double quote. Join two strings with +. Use the property .length to check number of characters in a string.\nlet user = \"peterchan\" let domain = 'ymail.com' let addr = user + \"@\" + domain let n = \"seven\".length // 5 String literals use backslash \\ to escape character, e.g. \\\", \\', \\\\ and \\n.\n// no need to escape because the string is delimited with ' let s1 = 'A string with \"double quoted text\".' // escape the backlash character let s2 = 'c:\\\\inetpub\\\\index.html' String literals can also use methods defined in the String class (ref). Examples:\nconst text = 'Mississippi' let p = text.indexOf('ss') // location of 'ss' const mesg = \"All the best\" p = mesg.slice(0,3) // 'All' p = mesg.slice(4) // 'the best' p = mesg.slice(-4) // 'best' p = mesg.slice(-4,-2) // 'be'  let A = \"202.175.3.3\".split('.') // an array ['202', '175', '3', '3'] Conversion User input are usually returned as string. Before calculation, use parseInt() or parseFloat() to convert the string into an integer / floating point number.\nconst s = \"3.14\" // unexpected result of string concatenation console.log(s+1) const pi = parseFloat(s) console.log(pi+1) In some code examples, you may also encounter using the prefix operator + to convert a string into a number. However, I would recommend to use parseFloat for easier understanding of the code.\nconst s = \"3.14\" const pi = +s // pi is the Number 3.14 There are various methods to change a number into a string.\nlet n = 12; let s1 = n.toString(); // \"12\" let s2 = '' + n; // automatic conversion in string concatenation A new features in ES6 is template string. Template strings support interpolation. They evaluate JavaScript expressions embedded in ${} and insert the result into the string. Notice the back ticks used to delimit a template string.\nlet user = \"Peter\"; let age = 18; let s = `${user}'s age is ${age}`; console.log(s); A longer example to illustrate number-string conversion. The browser built-in function prompt displays a dialog box with the given prompt and asks the user for a string input. See reference for more information about other browser built-in functions for input/output.\nlet s = window.prompt('Enter radius of the circle'); let r = parseFloat(s); console.log(`Area = ${Math.PI * r * r}`); Comparison You can compare numbers and strings using the operators \u003c, \u003c=, \u003e, \u003e=, == and !=. Comparison results are either true or false, which are the only two values in boolean data type.\n\"apple\" == \"Apple\" // false \"apple\" \u003c 'banana' // true The first four operators may convert the data if they are of different data type. It is especially confusing if you compare numbers with strings. JavaScript converts strings into numbers before comparison. In general, it is better to do the conversion by yourself.\n\"1\" == 1.0 // true 3 == '3.0' // true '3' == '3.0' // false! Some authors recommend the usage of === instead of == in comparison. The operator === does not convert values before comparison. Similarly, !== checks whether two values are not equal without automatic type conversion.\nSimilar to Java, you can use \u0026\u0026 and || to combine comparison tests.\nControl structure The control structure if, for and while are similar to those in Java. Please read the online reference of if…else, for, while and switch for detail.\nlet a = 1, b = -3, c = 2; // roots are 1 and 2 // let a = 1, b = 0, c = 1; // roots are i and -i  let det = b * b - 4 * a * c; let root1, root2; if (det\u003e=0) { // these two are Number  root1 = (-b - Math.sqrt(det)) / (2*a); root2 = (-b + Math.sqrt(det)) / (2*a); } else { // these two are String.. sorry, no complex number support  root1 = `${-b/2/a}- ${Math.sqrt(-det)/2/a}i`; root2 = `${-b/2/a}+ ${Math.sqrt(-det)/2/a}i`; } console.log(`${a}x^2 + ${b}x + ${c}= 0`); console.log(`The roots are ${root1}and ${root2}`); Examples on loops.\n// calculate 1+2+3+...+10; let sum = 0; for (let k=1; k\u003c=10; k++) { sum += k; } console.log(`The sum of 1+2+...+10 = ${sum}.`); // calculate 1*1+2*2+...+n*n, where n*n\u003c100; let i = 1; let sum = 0; while (i*i\u003c100) { sum += i*i; i++; } console.log(`The sum of squares \u003c 100 is ${sum}.`) A note on loose typing You might have noticed that when you define a variable with let x or const x, you don’t need to specify a data type. A JavaScript variable is not tied to a specific data type in declaration, and can hold values of different data types.\nlet x = 10; x++; // x is a Number x = x.toString(2); // binary representation console.log(x); // x is now a String Exercise   Write a program to calculate the sum of even positive numbers up to 30. (The answer should be 240)\n  The following program asks the user a number n, and print a n by n squares to console.\nlet s = window.prompt('Enter size of the square'); /* convert the input string into a number */ let n = parseInt(s); /* build a line with n stars */ let line = ''; for (let i=0; i\u003cn; i++) { line = line + '* '; } /* build a square with n lines */ let sqr = ''; for (let i=0; i\u003cn; i++) { sqr = sqr + line + '\\n';} console.log(sqr); Modify the program to print an empty square.\n * * * * * * * * * * * * * * * *    The sample answers are available at ex2-1q1.js and ex2-1q2.js respectively.\n",
    "description": "",
    "tags": null,
    "title": "2-1 Basic data types and control",
    "uri": "/2basic/2-1/"
  },
  {
    "content": "RPC-style Web API A common design style of Web API is RPC-style (Remote Procedure Call). A RPC-style Web API allocates one URL for each function or operation. These URLs represent an action and are usually named with a verb. The following table shows five endpoints in a Web API to manipulate products in a database. They implement four common operations on data known as CRUD (Create, Retrieve, Update and Delete).\n   method URL function     GET /products.info Retrieve info about a specific product   GET /products.list List all products   POST /products.create Add a new product   POST /products.update Update a product   POST /products.delete Delete a product    Each endpoint is identified with the HTTP method (either GET or POST) and an URL. An endpoint uses GET if the operation is read-only. If the operation may cause some action or side-effect on the server side, the endpoint must use POST.\nIn addition, when you design a Web API, you also need to specify:\n input parameters, and whether they are in URL-encoded or json format, and whether to pass them in URL query or request message body results, whether they are in URL-encoded or json format how to report error  Retrieving items Readonly endpoints in RPC-style Web APIs should use the GET method. This informs the proxy servers that the responses from these endpoints are cacheable, and may be reused within an expiry time.\nA Web API may return result in either URL-encoded (i.e. key-value pairs) or JSON. Key-value pairs are only suitable for simple values. JSON is more flexible in representing data structure.\nBelow is a sample HTTP request to retrieve a product with a specified ID:\nGET /products.info?id=5 HTTP/1.1 Host: example.com Below is a sample response message returned by the Web API. The JSON payload has Content-type: application/json.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 116 { \"id\": 5, \"productName\": \"Coke candy\", \"category\": \"Confections\", \"unitPrice\": 10.5, \"unitsInStock\": 20 }  Similarly, search operations should use the GET verb because they are readonly operations. You can design the parameters to specify the search criteria. For example, to list all ‘confections’ products with a unit price less than or equal to $10, you can implement the parameters category and maxUnitPrice for filtering the result set. The client can then send the following request.\nGET /products.list?category=Confections\u0026maxUnitPrice=10 HTTP/1.1 Host: example.com HTTP/1.1 200 Ok Content-type: application/json Content-length: 6060 { \"count\": 98, \"items\": [ { \"id\": 5, \"productName\": \"Coke candy\", \"unitPrice\": 10.5 ... }, { \"id\": 6, \"productName\": \"Chocolate bar\", \"unitPrice\": 25.0 ...}, ... ] } Update operations The endpoints of any update operations must use POST. It indicates that any web proxy servers between the client and the Web API should not cache responses of the operations. In update operations, there are usually some input parameters. In your design of the API, you can choose either to use simple parameters as URL-encoded (i.e. key-value pairs) or JSON data in the request message body.\nBelow is a sample request for adding a new product products.create in the Web API.\nPOST /products.create HTTP/1.1 Host: example.com Content-type: application/x-www-form-urlencoded Content-length: 53 productName=Great+new+chocolate\u0026category=Confections\u0026unitPrice=20\u0026unitsInStock=100 And the equivalent version using JSON payload.\nPOST /products.create HTTP/1.1 Host: example.com Content-type: application/json Content-length: 113 { \"productName\": \"Great new chocolate\", \"category\": \"Confections\", \"unitPrice\": 20, \"unitsInStock\": 100 }  URL-encoded payload is commonly used in Web APIs in client side of modern web apps. One reason is that the input parameters are usually simple in these APIs. Furthermore, it is easier to work with key-value pairs in client-side programming.\nIn this chapter, we’ll mostly use JSON payload for simplicity.\n A successful response from an update operation may provide some info about the update operation, e.g. the id of the newly created record. Alternatively, the API designer may choose to return a representation of the newly created product as follows.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 125 { \"id\": 21, \"productName\": \"Great new chocolate\", \"category\": \"Confections\", \"unitPrice\": 20, \"unitsInStock\": 100 }  In the product.update endpoint, the client must specify the id of the product to change, and then list the properties and their new values.\nPOST /products.update HTTP/1.1 Host: example.com Content-type: application/json Content-length: 141 { \"id\": 5, \"productName\": \"Coke candy (Update price and stock)\", \"category\": \"Confections\", \"unitPrice\": 13.8, \"unitsInStock\": 32 } After successful update of the item, the server usually returns a 200 response with the updated representation of the item in the response body. This is similar to the response for adding a new product.\n For the delete operation, the client must specify the id of product to delete in the products.delete endpoint.\nPOST /products.delete HTTP/1.1 Host: example.com Content-type: application/x-www-form-urlencoded Content-length: 4 id=3 An equivalent version using JSON payload follows.\nPOST /products.delete HTTP/1.1 Host: example.com Content-type: application/json Content-length: 10 { \"id\":3 }  Some API designers prefer to pass simple parameters as URL query in POST requests, for example …\nPOST /products.delete?id=3 HTTP/1.1 Host: example.com  A successful response for the delete operation usually contains no data. The Web API designer may choose a response with no body using the 204 status code,\nHTTP/1.1 204 No content or, for consistency, a response with an empty JSON value.\nHTTP/1.1 200 Ok Host: example.com Content-type: application/json Content-length: 2 {} More examples of RPC Web APIs The Slack API is a popular Web API that use the RPC style. Consider, for example, the numerous endpoints in the conversations method group. These endpoints allow a client to create a channel, join a channel, leave a channel, kick someone out of a channel, invite someone to join a channel, and list the messages in a channel.\n",
    "description": "",
    "tags": null,
    "title": "5-2 RPC Web API",
    "uri": "/5appserver/5-2/"
  },
  {
    "content": "Asynchronous I/O handling Input / output operations, e.g. file reading/writing and network transactions, are much slower than CPU. Introductory programming examples (e.g. in Java and Python) typically use synchronous function call to perform I/O. Each file operation takes relatively long time to complete, and while the function call is waiting the I/O completion, the process / thread is blocked. When the I/O is completed, the program can continue to the next line in the program.\nimport java.io.File; import java.util.Scanner; public class JavaExample { public static void main(String[] args) throws Exception { // wait some time for the file open  File file = new File(\"test.txt\"); Scanner sc = new Scanner(file); while (sc.hasNextLine()) // wait some time to read some text from file  System.out.println(sc.nextLine()); } } However, there is only 1 thread to run JavaScript code in most platforms (one thread per browser window, one thread per Node.js program). If this thread blocks to wait for I/O completion, the whole Node process is blocked and cannot process other events. Consider the following example.\n There is exception. A Node.js that can only use 1 thread results in bad CPU utilization of multi-core CPUs. So modern JavaScript platforms support multiprocessing, e.g. Web workers in web browsers, and worker threads in Node.js.\n Therefore, JavaScript libraries employ asynchronous function call to handle I/O completion. Consider the following example, in which the program sends a DNS query to a name server to find the IP addresses of a domain name. The function call dns.resolve() starts the network transaction (i.e. sends a DNS query), and registers a callback function for I/O completion. But it does not block. When the name server returns a reply, the event loop calls the callback function.\n/// p111-a.mjs import dns from 'dns'; const govHost = \"www.gov.mo\"; dns.resolve(govHost, (err, records) =\u003e { if (err) { console.error(err); return; } console.log(`${govHost}resolves to ${records}`); }); // this runs before we got an answer from a name server let x = 1+2; // event loop Similarly, file input/output usually use asynchronous callback to handle I/O completion. For more information, read online reference for fs.readFile and fs.writeFile.\n// p112.mjs import fs from 'fs'; /* function getPrime() returns an array of prime numbers */ const textData = genPrime(200).toString(); fs.writeFile('./prime.txt', textData, 'utf8', (err)=\u003e{ if (err) throw err; console.log('Some prime numbers are written to prime.txt'); }); // at this point, file write is still in progress // ...  // event loop waits for writeFile to finish // p113.mjs import fs from 'fs'; fs.readFile('./prime.txt', 'utf8', (err, data)=\u003e{ if (err) throw err; let primes = data.split(','); console.log(`${primes.length}prime numbers found in prime.txt.`); console.log(`The last 5 are ${primes.slice(-5)}`); }); // ... // event loop waits for readFile to finish The three I/O operation above (dns.resolve, fs.readFile, fs.writeFile) may either fails with an Error or succeeds and return the data requested. Node.js typically uses completion callback with two parameters to handle these. The first is often an Error object err to report I/O error. If no error has occurred and the I/O operation completes successfully, err equals null or undefined, and the result of the I/O operation is given in the second parameter.\n In the examples, we throw the error object while the event loop calls the callback function. Since the event loop does not catch any exception, throwing the error object will abort the Node.js process.\n And remember, I/O completion callbacks usually are called by the event loop, and usually after all statements of the JavaScript program has executed. In this aspect, completion callbacks are similar to the callbacks in one-time timers.\nsetTimeout( /* this callback runs 10min later, after all the statements below */ ()=\u003e{ }, 10*60*1000 ); // ... // ...  // event loop Sequential I/O operations The execution time of asynchronous callbacks make the proper sequencing of I/O operations confusing to beginning JavaScript programmers. To properly order two I/O operations, you often need to put the second I/O operation inside the callback of the first I/O operation. Consider the following example of copying the file mpi-info.txt to copy-mpi-info.txt. example p115.mjs\n// p115.mjs - file copy import fs from 'fs'; fs.readFile('mpi-info.txt', 'utf8', (err, data) =\u003e { if (err) throw err; // at this moment, file read is done  // `data` contains content of the input file  fs.writeFile('copy-mpi-info.txt', data, 'utf8', (err) =\u003e { if (err) throw err; }); }); If the two calls of readFile and writeFile are not nested, but put into a sequence as in example p116-mistake.mjs, writeFile will not receive any data from readFile.\nCallback hell In general, doing some I/O operations in sequence would involve nesting callback functions. The result is sometimes known as callback hell in the Node community. We’ll explain a modern JavaScript language feature called Promise that mitigates this problem.\n// p117.mjs - concatenate two files import fs from 'fs'; fs.readFile('p115.mjs', 'utf8', (err, file1Data)=\u003e{ if (err) throw err; fs.readFile('p116-mistake.mjs', 'utf8', (err, file2Data)=\u003e{ if (err) throw err; fs.writeFile('combined.txt', file1Data+file2Data, 'utf8', (err)=\u003e{ if (err) throw err; }); }); }); Events and event handlers On the other hand, some I/O processes detect some kind of event several times (0, 1, 2 or more), and need to run a callback function asynchronously to handle each event. For example, a web server runs a callback whenever it receives an HTTP request from a browser. The following example uses the built-in module http to write a simple web server.\n// p114.mjs import http from 'http'; let server = http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.write(\"Hello browser\"); res.end(); }); // ... Try to run the example p114.mjs. The HTTP server actually support several more kinds of events, and you can register event handler for each kind of event.\nEvent handlers are similar to the callback function of a periodic timer. They are also similar to event handlers in web browsers.\nsetInterval( /* this callback runs every minute, after all the statements below */ ()=\u003e{ }, 60*1000 ); // ... // ...  // event loop Downloadable example The example source files are available here.\n",
    "description": "",
    "tags": null,
    "title": "4-2 Asynchronous callback",
    "uri": "/4server/4-2/"
  },
  {
    "content": "A minimal Vue application  The example p301.html is a ‘bare-bones’ example of a Vue application.\n\u003cdiv id=\"app\"\u003e \u003cdiv\u003e1+2*3 = {{ 1+2*3 }}\u003c/div\u003e \u003cdiv\u003eIt is now {{ (new Date).toLocaleTimeString() }}\u003c/div\u003e \u003c/div\u003e \u003cscript\u003e // define an empty Vue options object const options = { }; // create a Vue component, mounted to the HTML template const vm = Vue.createApp(options).mount('#app'); \u003c/script\u003e A Vue application is created using Vue.createApp(). The application contains a root component, which is mounted to a certain element in the document tree. (In this example, the mount point is #app). The data properties of the component is defined in an options object, and the component is rendered according to an HTML template. In this example, the HTML template is embedded inside the mount point. (We’ll show other ways to write the template later in this section.)\nIn the template, you can use the moustache {{ }} notation to run JavaScript expressions. The result of the expression will be inserted into the template, and shown in the browser display.\nData properties and reactivity In the next example p302.html, we add some data properties to the view model. This is done by adding a method data() to the options object. Vue calls this method to create reactive proxy of the data properties.\nInside the template, we can display a data property with {{ property_name }} or {{ this.property_name }}. The mustache notation can be used in the content of HTML elements, but not as attribute value. To bind an HTML attribute to a data property, use v-bind:attr or the shorthand notation :attr.\nBoth {{ }} and v-bind respond to changes in data property. This is an important feature of Vue called reactivity. We only need to write the template once. When some data properties are updated, Vue will update the document tree efficiently to reflect the changes.\n\u003cdiv id=\"app\"\u003e \u003cimg :src='conditionURL' style='float: left; padding-right: 1em'\u003e \u003cdiv\u003eTemperature: {{ temperature }}°C\u003c/div\u003e \u003cdiv\u003eRain: {{ rain }}%\u003c/div\u003e \u003c/div\u003e \u003cscript\u003e // define a Vue options object const weather = { data() { return { temperature: 28, rain: 20, conditionURL: 'image/sunny.png' } } }; // create a Vue component, mounted to the HTML template const vm = Vue.createApp(weather).mount('#app'); \u003c/script\u003e This example also shows two other ways to write templates of Vue. Example p302-a.html provides the template as the string value of the template property of the options object. Example p302-b.html embeds the template in the HTML document using the \u003cscript type=\"text/x-template\"\u003e tags, and uses the template property to refer to the template text in the \u003cscript\u003e tag.\nBinding to expression and style binding Sometimes, it is not enough to bind a HTML attribute to a data property alone. You can implement simple logic with an expression in the binding to an attribute. In addition, the style and class attributes of HTML can bind to JavaScript objects. (For more detail about style and class bindings, please refer to the online reference.) The first excerpt from example p303.html below demonstrates this.\n\u003cdiv id=\"app\"\u003e \u003cdiv\u003e Temperature: \u003cspan :style=\"styleTemperature\"\u003e{{ temperature }}°C\u003c/span\u003e \u003cimg :src=\"temperature\u003e=14 ? 'image/high-temp.png' : 'image/low-temp.png'\"\u003e \u003c/div\u003e \u003c!-- some content omitted --\u003e \u003c/div\u003e \u003cscript\u003e const weather = { data() { return { temperature: 28, styleTemperature: { fontWeight: 'bold', color: 'orange' }, rain: 10, } } // the computed properties are omitted }; const vm = Vue.createApp(weather).mount('#app'); \u003c/script\u003e When the bound values involve more complicated logic, you can define computed properties by writing methods in the computed property. (online reference Computed properties work as read-only properties of the view model / component. When you define a computed property, you can refer to data property through this.\n\u003cdiv id=\"app\"\u003e \u003c!-- some content omitted --\u003e \u003cdiv\u003eRain: \u003cspan :style=\"styleRain\"\u003e{{ rain }}%\u003c/span\u003e \u003cimg :src=\"rainImageURL\"\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e // define a Vue options object const weather = { data() { return { temperature: 28, styleTemperature: { fontWeight: 'bold', color: 'orange' }, rain: 10, } }, computed: { styleRain() { const r = parseFloat(this.rain); let color; if (r \u003c 30) { color = { color: 'yellow', backgroundColor: 'lightblue' } } else if (r \u003c 70) { color = { color: 'red', backgroundColor: 'lightgreen' } } else { color = { color: 'black', backgroundColor: 'lightgray' } } return { ...color, padding: '0em 1em' }; }, rainImageURL() { const r = parseFloat(this.rain); if (r \u003c 30) return 'image/rainy-1.png'; if (r \u003c 70) return 'image/rainy-2.png'; return 'image/rainy-3.png'; } } }; // create a Vue component, mounted to the HTML template const vm = Vue.createApp(weather).mount('#app'); \u003c/script\u003e ",
    "description": "",
    "tags": null,
    "title": "3-2 Vue application basics",
    "uri": "/3client/3-2/"
  },
  {
    "content": "JavaScript Basics This chapter goes through the basics of the JavaScript programming language.\n 2-1. Basic data types and control structures  numbers, strings, conversion, selection and looping   2-2. Arrays  create an array, array index, basic methods   2-3. Functions  function declaration, variable scope   2-4. Objects as data structure  model data by mixing arrays and objects   2-5. Functions, as objects and callbacks  function expression, arrow function, passing function objects into and out of functions   2-6. Objects with methods  Object literal methods, this   2-7. Some built-in class: Collections and iterable objects  built-in classes: Array, Date, Map define class    There are lots of free JavaScript tutorials, books and reference material on the web. Below are some of my favourites:\n JavaScript for impatient programmers The Modern JavaScript Tutorial (with both English and Chinese versions) Mozilla reference  ",
    "description": "",
    "tags": null,
    "title": "JavaScript basics",
    "uri": "/2basic/"
  },
  {
    "content": "This lab goes through the basics of the JavaScript arrays.\nArray An array keeps values in a sequence. Arrays can change size in run-time. You retrieve an element from an array by position. Use the operator [] to locate an element at the given index.\nlet a = [ 1, 3, 5, 7, 9 ]; console.log(`The second odd number is ${a[1]}.`); let empty = [ ]; // empty array empty[1] // undefined The length property refers to the number of elements inside the array. A common method to iterate an array is to use for loop. You can read and write elements inside the loop using [ ].\nlet p = [ 2, 3, 5, 7, 11 ]; // small primes for (let i=0; i\u003cp.length; i++) { console.log(p[i]); } JavaScript arrays are a reference data type. When you assign an array variable to another, both variables refer to the same array object.\nlet a = [1,3,5]; let b = a; b[3] = 7; // append 7 to array b, which is the same object as array a console.log(a); Iteration ES6 has a new control structure for of to iterate arrays and other iterable objects. You can use it to read the entries of an array one by one. This control structure is convenient when you only need to access the content of an array, but not the position.\nlet p = [ 2, 3, 5, 7, 11 ]; // small primes for (let x of p) { console.log(x); } It should be noted that there is a similar control for in in JavaScript. However, it may not work as you would expect. Try change the above example to use for in.\nIn case you need read-only access to the entries and their position, use the method .entries() of Array. The method is an iterable list of tuples [index, value].\nlet num = [ 'zero', 'um', 'dois', 'tres' ] for (let [idx, s] of num.entries()) { console.log(`In Portuguese, ${s}means ${idx}.`) } Basic array methods Arrays are objects in JavaScript and have some built-in methods. See online reference for a list of all methods. The following shows some common methods.\nlet A = [2,4]; A.push(6); // A becomes [2,4,6] A.pop(); // returns 6. A becomes [2,4] A.unshift(0); // A becomes [0,2,4] A.shift(); // returns 0  let b = [202,175,3,3]; let s = b.join('.'); // \"202.175.3.3\" Arrays are useful to keep some values in order. The following example generates prime numbers less than 200. Is also demonstrates the usage of continue and loop label to force the next iteration. Please refer to online help for the detail usage of break and continue.\nlet p = [2, 3, 5, 7]; // give a label to the first for loop loop1: for (let k=9; k\u003c200; k+=2) { loop2: for (let n of p) { // if k is divisible by a prime in p, continue onto k+2  if (k % n == 0) continue loop1; } // after the above for loop, k is verified as prime  p.push(k); } console.log(p); Destructuring and spread syntax A recent feature called destructuring assignment makes it convenient to extract values from arrays.\nlet a, b; [a, b] = [1,2,3,4,5]; // a is 1, b is 2 [, , a, , b] = [1,2,3,4,5]; // a is 3, b is 5  let rest; [a, b, ...rest] = [2, 3, 5, 7, 11, 13]; // rest is [5, 7, 11, 13] The spread syntax ...array also allows to insert content of one array into another.\nlet a = [1, 2, 3]; let b = [0, ...a]; // b is [0, 1, 2, 3] Exercise   Given an array num, write a JavaScript program to find the largest number in the array. Use the following code to test your function.\nlet num = [32, 15, 20, 41, 2, 39]; // your work here   You can put an array as element inside another array. This is known as nested array, and can represent two dimensional arrays, e.g. a matrix. Given a 2D matrix in the variable mat, write a JavaScript program to find its inverse. See reference to review the mathematics of inverse of 2x2 matrix.\nlet mat = [ [ 1, 0 ], [-1, 3 ] ]; // your work here   Given a constant n, write a JavaScript program to find the first n Fibonacci number.\nconst n = 10; let fib = [ ]; // your work here // fib should contain [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]   The sample answers are available at ex2-2q1.js, ex2-2q2.js and ex2-2q3.js respectively.\n",
    "description": "",
    "tags": null,
    "title": "2-2 Arrays",
    "uri": "/2basic/2-2/"
  },
  {
    "content": "REST is the most popular way to design Web APIs. In a REST Web API, actions are designed around resources. Each resource is identify by a URL. A client applies the standard HTTP verbs (including GET, PUT, POST, DELETE, POST) on the resources to perform CRUD operations (Create, Retrieve, Update, Delete).\nFor example, in an online shopping site, there may be resources about products, customers and their orders. These are represented by the following URLs.\n   resource type collection individual item     product /products /products/id   customer /customers /customers/id   order /orders /orders/id    In this lab, we’ll demonstrate how to do the following using a hypothetical REST API.\n retrieve a single product list all products update an existing product delete a product create a new product  Retrieve a single item To retrieve information about the product with a given ID, a client uses a request similar to this.\nGET /products/5 HTTP/1.1 Host: example.com The Web API returns the product data in JSON format as follows.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 116 { \"id\": 5, \"productName\": \"Coke candy\", \"category\": \"Confections\", \"unitPrice\": 10.5, \"unitsInStock\": 20 } In principle, REST APIs should reuse HTTP status code as much as possible to report errors. For example, if the server cannot find a product of the given ID, it may return 404 error as follows.\nHTTP/1.1 404 Not found However, the server often needs to report more detail about the errors, or there may not be suitable HTTP status code to report some errors. We’ll discuss how to handle this later.\nRetrieve all items in a collection To list all products, use the GET verb on the product collection resource.\nGET /products HTTP/1.1 Host: example.com The Web API returns the product data as follows.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 6060 { \"count\": 98, \"items\": [ { \"id\": 5, \"productName\": \"Coke candy\", \"unitPrice\": 10.5 }, { \"id\": 6, \"productName\": \"Chocolate bar\", \"unitPrice\": 25.0 }, ... ] } Update an item HTTP provides a verb PUT to replace / update an existing resource in the server. The request body must contain a representation of the whole resource.\nPUT /products/5 HTTP/1.1 Host: example.com Content-type: application/json Content-length: 142 { \"id\": 5, \"productName\": \"Coke candy (Update price and stock)\", \"category\": \"Confections\", \"unitPrice\": 12.5, \"unitsInStock\": 32 } Sometimes, we may only need to update a few properties of a resource with many properties. HTTP provides another verb PATCH to list only the properties to be updated in the request payload. For example, the following request updates the unit price only.\nPATCH /products/5 HTTP/1.1 Host: example.com Content-type: application/json Content-length: 21 { \"unitPrice\": 13.8 } After processing the PUT or PATCH request, the server has to report success / failure. If the update is successful, the server often returns the most up-to-date version of the resource.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 142 { \"id\": 5, \"productName\": \"Coke candy (Update price and stock)\", \"category\": \"Confections\", \"unitPrice\": 13.8, \"unitsInStock\": 32 } When you design the Web API, you may also choose to just return a code for successful processing, and don’t include an updated representation, as follows.\nHTTP/1.1 204 No content Delete an item HTTP supports a verb DELETE to delete a resource.\nDELETE /products/5 HTTP/1.1 Host: example.com If successful, the server returns 204, or 200 with an empty object.\nHTTP/1.1 204 No content or\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 2 {} Error reporting In principle, REST APIs should reuse HTTP status code as much as possible to report errors. For example, if the server cannot find a product of the given ID when the client sends a GET, PATCH or DELETE request, it may return 404 error.\nHTTP/1.1 404 Not found Some designers use HTTP status codes like 400 and 500 to report runtime error. An example is GitHub API client error. Web APIs often describe the errors in the JSON payload using some specified fields, e.g. errorCode. Therefore, a client can always check the existence of any error, and the detail of the error, from the specified fields in the payload.\nHTTP/1.1 400 Bad Request Content-type: application/json Content-length: 62 { \"errorCode\": 1001, \"message\": \"Date format error in input\" } HTTP/1.1 500 Internal Server Error Content-type: application/json Content-length: 63 { \"errorCode\": 1002, \"message\": \"Database connection problem\" } Since the error detail is already available in the JSON payload, some Web APIs always return the responses using 200 status code. This is convenient for client programming because all information about the error can be found in the JSON payload, and programmers do not need to check the HTTP status code.\nHTTP/1.1 200 Ok Content-type: application/json Content-length: 63 { \"errorCode\": 1002, \"message\": \"Database connection problem\" } Create an item In theory, one can create an item by sending a PUT request. However, you need to know the ID of the new item in order to build the resource URL. This is not always possible because the ID is usually assigned by the server.\nA common solution in REST Web APIs is to POST to the collection resource for the new item. (Notice the ID is not given.)\nPOST /products HTTP/1.1 Host: example.com Content-type: application/json Content-length: 113 { \"productName\": \"Great new chocolate\", \"category\": \"Confections\", \"unitPrice\": 20, \"unitsInStock\": 100 } After creating the new item, the server returns a successful response with the location of the newly created resource in location header. The status code 201 means that a new resource has been created.\nHTTP/1.1 201 Created Location: http://example.com/products/98 Web APIs are often designed to return the representation of the newly created resource in the response body.\nHTTP/1.1 201 Created Location: http://example.com/products/98 Content-type: application/json Content-length: 126 { \"id\": 98, \"productName\": \"Great new chocolate\", \"category\": \"Confections\", \"unitPrice\": 20, \"unitsInStock\": 100 } Resources with more complicated structure The JSON representation of a resource may be more complicated than a list of properties of simple values. For example, an order contains several lines, each line specifies a product and its quantity.\nGET /orders/10248 HTTP/1.1 Host: example.com HTTP/1.1 200 Ok Content-type: application/json Content-length: 302 { \"id\": 10248, \"customerId\": 85, \"orderDate\": \"2012-07-04\", \"freight\": 32.38, \"shipCity\": \"Reims\", \"lines\": [ { \"productId\": 11, \"unitPrice\": 14, \"quantity\": 12 }, { \"productId\": 42, \"unitPrice\": 9.8, \"quantity\": 10 }, { \"productId\": 72, \"unitPrice\": 34.8,\"quantity\": 5 } ] } Searching items If the searching is limited a single kind of resources (e.g. products), we can extend the list item endpoint (e.g. GET /products) with search criteria formatted as a query string.\nFor example, you can introduce two parameters category and maxUnitPrice in your API to support product search for a certain category and a unit price less than a given price.\nGET /products?category=Confections\u0026maxUnitPrice=10 HTTP/1.1 Host: example.com Pagination The result of searching or listing items often consists of a large number of items, which may overwhelm a client in computing resource consumption. Web APIs often support pagination, i.e. breaking the search result into several batches (or pages).\nA familiar example of pagination is web search. For example, here are the URLs of the first three pages when search ‘Web API design’ in bing.com.\n page 1: https://www.bing.com/search?q=Web+API+design page 2: https://www.bing.com/search?q=Web+API+design\u0026first=11 page 2: https://www.bing.com/search?q=Web+API+design\u0026first=21  The above technique is called offset-based pagination. Typically, there are two parameters, the first to specify the offset (index of the first item to include in this page), and the second to specify the number of items in this page.\nTwo examples of offset-based pagination in Web APIs:\n req|res REST API GitHub REST API supports pagination. Example: https://api.github.com/user/repos?page=2\u0026per_page=100  When the items include a temporal property (e.g. post time of tweets) or other properties that are ever increasing (e.g. tweet id in Twitter), you can also paginate using these properties as the offset. Example: GET https://api.twitter.com/2/tweets/search/recent?start_time=2021-10-07T00:39:00Z\u0026max_results=20\n Another technique is called cursor-based pagination. Number of items to return in a page is specified in a query parameter (e.g. max_results). When the API server returns a response, it includes a token next_token, which the client can include in the next request to indicate the start position of the next page. (Similarly, the API also provides previous_token) for navigation to the previous page.\nThe following example is from the Twitter API endpoint to retrieve followers of a certain user. (online ref).\nTo get the first 3 followers of the user with id 12345678:\nGET /2/users/12345678/followers?max_results=3 HTTP/1.1 Host: api.twitter.com The Web API returns a response with a JSON payload similar to the following.\n{ \"data\": [ { \"id\": \"7000001\", \"name\": \"..\", \"username\": \"..\" }, { \"id\": \"8003004\", \"name\": \"..\", \"username\": \"..\" }, { \"id\": \"3030003\", \"name\": \"..\", \"username\": \"..\" } ], \"meta\": { \"result_count\": 3, \"next_token\": \"DEFGABCDJKKLL\" } } To fetch the next page of the result, you can then use the following request.\nGET /2/users/12345678/followers?max_results=3\u0026pagination_token=DEFGABCDJKKLL HTTP/1.1 Host: api.twitter.com Further information:\n Twitter REST API v2: Pagination Facebook Graph API: Paginating APIs GitHub REST API: Traversing with pagination  Sub-resources / nested route Consider the Web API at https://jsonplaceholder.typicode.com/ which exposes the resource users and their posts and albums. Sending a GET request to /users and /posts will retrieve a list of users and posts respectively. Very often, a client needs to find the posts written by a certain user. Some API designer model such 1 to many relationship with sub-resource (also known as nested routes). A GET request to get the posts by user 1 would be https://jsonplaceholder.typicode.com/users/1/posts .\nGET /users/1/posts HTTP/1.1 Host: jsonplaceholder.typicode.com This sample Web API also model the relationship that a post may have many comments, a user may have many albums, and an album may include many photos.\nMore examples of REST Web APIs REST style is used in many Web APIs. A popular API is the Twitter API V2. Postman collection\n GET /2/users/:id GET /2/users/:id/tweets (online ref) GET /2/tweets/:id (online ref) GET /2/tweets/search/recent (online ref) The Twitter API v2 currently (Oct 2021) does not provide an endpoint for posting tweets.  In the API v1.1, it is POST statuses/update (online ref) But in API v2, it would be more natural to use POST /2/users/:id/tweets    A limitation of REST APIs is that only a limited set of standard HTTP methods (e.g. GET, PUT) can be used on resources. To model other actions, the Twitter API uses sub-resources to represent actions.\n likes (online ref)  POST /2/users/:id/likes DELETE /2/users/:id/likes/:tweet_id GET /2/users/:id/liked_tweets GET /2/tweets/:id/liking_users   retweets (online ref)  POST /2/users/:id/retweets DELETE /2/users/:id/retweets/:source_tweet_id GET /2/tweets/:id/retweeted_by   Also check the endpoints for ‘follows’  Another well defined example of REST API is (GitHub REST API).\n",
    "description": "",
    "tags": null,
    "title": "5-3 REST Web API",
    "uri": "/5appserver/5-3/"
  },
  {
    "content": "Promise, basics In last section, we saw that many I/O operations take a callback function to report the result (if successful) or the error (if failing).\nimport dns from 'dns'; const govHost = \"www.gov.mo\"; dns.resolve(govHost, (err, records) =\u003e { if (err) throw err; console.log(`${govHost}resolves to ${records}`); }); These asynchronous callbacks are efficient and easy to understand. However, when we need to organize a sequence of asynchronous operations, excessive nesting of the callback functions will soon make the code overwhelming.\nModern JavaScript introduces Promise, an abstraction to model the result and error from an operation that will complete in the future. According to MDN article - Using promises,\n A Promise is an object representing the eventual completion or failure of an asynchronous operation.\n Below is a rewrite of the DNS resolve example using promises.\n// p121-promdns.mjs import { promises } from 'dns'; const resolver = new promises.Resolver(); const govHost = \"www.gov.mo\"; resolver.resolve(govHost).then( (records) =\u003e { // succeed  console.log(`${govHost}resolves to ${records}`); }).catch( (err) =\u003e { // fail  console.log(`Resolve fails with ${err}`); }) The line resolver.resolve(govHost) creates a Promise object. A promise has both a state and a result. At start, the program is waiting for a reply from a name server, and the promise is said to be in the pending state, and have a undefined result. After some time, the program may receive DNS records successfully, and the state of the promise changes to fulfilled, and the result contains the resolution records. On the other hand, if the DNS resolution fails, the state of the promise becomes rejected.\nSince a promise represents the result/error of a task to be completed, when its state changes from pending to fulfilled or rejected, it will never change again. The promise is said to be settled. We also say resolve a promise to refer to the action that the promise becomes fulfilled with a result, and reject a promise to refer to that action that the promise becomes rejected with an error.\nPlease refer to the state diagram in the online reference promise basics for more information about the three states of a promise.\nAlso try the promise dice example to examine state change of a promise in a web browser.\nObtaining the result of a promise The result is not a property of the promise object. To access the result/error of a promise object, use the .then() or .catch() methods.\nThe full form of .then() has two parameters: one is the callback when the promise is resolved (successful completion), and the other is the callback when the promise is rejected (failed completion). Try the examples p122-success.mjs and p122-failure.mjs.\n// p122-success.mjs import { promises } from 'dns'; const resolver = new promises.Resolver(); const host = \"www.gov.mo\"; const prom = resolver.resolve(host); prom.then( rec =\u003e { console.log(`${host}resolves to ${rec}`) } , err =\u003e { console.log(`Name server returns an error: ${err}`) } ); If you’re only interested in the result in successful completion, you can use .then() with one callback only. The callback is sometimes known as then handler.\nprom.then(rec =\u003e { console.log(`${host}resolves to ${rec}`) }) On the other hand, if you’re only interested in the error object in case of failure, you can use .catch() with one callback. The callback is sometimes known as catch handler.\nprom.catch(err =\u003e { console.log(`Name server returns an error: ${err}`) }) Also try to add handler to the promise dice.\nChaining promises We often need to perform I/O operations one after another. For example, to copy a file, we need to call readFile to get the file content, and then call writeFile to write the content to a copy.\nIn the last section, we use nested callbacks to do this. Now, let’s examine the promise versions of readFile and writeFile. Both functions return promises.\nreadFile('mpi-info.txt', 'utf8').then( data=\u003e{ // data contains content of the input file  console.log(data); }); let data = \"content read earlier\"; writeFile('copy-mpi-info.txt', data, 'utf8').then( ()=\u003e{ console.log(\"Finish copying\"); }); The method .then() returns another promise object, and it allows us to chain .then() together in the form prom.then().then().then(). What promise the .then() method returns depends on the inner working of the handler.\n If the handler returns a promise, .then() also returns the same promise. If the handler returns a normal value (e.g. number, string, plain object), .then() returns a fulfilled promise with the return value as result. If the handler throws an exception, .then() returns a rejected promise with the exception object as error.  With this in mind, we can rewrite the file copy example in the last section using promises.\n// p123.mjs import { readFile, writeFile } from 'fs/promises'; readFile('mpi-info.txt', 'utf8').then( data=\u003e{ // data contains content of the input file  return writeFile('copy-mpi-info.txt', data, 'utf8') }).then( ()=\u003e{ console.log(\"Finish copying\"); }) Handling errors In a promise chain prom.then().then(), if any handler throws an exception (which is wrapped up as a rejected promise) or any then() returns a rejected promise, the chain will skip the remaining then() and run the nearest catch(). Therefore, we can handle the errors in a promise chain by adding a catch() handler near the end of the chain.\n// p124.mjs import { readFile, writeFile } from 'fs/promises'; readFile('non-exist-mpi-info.txt', 'utf8').then( data=\u003e writeFile('copy-mpi-info.txt', data, 'utf8') ).then( ()=\u003e{ console.log(\"Finish copying\"); }).catch( err=\u003e{ console.error(\"promise catch \"+err); }) Test error handling of promise in promise dice.\nawait and async Modern JavaScript provides two keywords await and async then make using promises even easier.\nGiven a promise prom, you can wait and obtain its result with let result = await prom. If the promise is rejected, then the await statement throws an exception. Essentially, await makes promises work like synchronous I/O functions in Java or Python. Below is a rewrite of p124.mjs (file copy) using await.\n// p125.mjs import { readFile, writeFile } from 'fs/promises'; try { let data = await readFile('mpi-info.txt', 'utf8'); await writeFile('copy-mpi-info.txt', data, 'utf8'); console.log(\"Finish copying\"); } catch (err) { console.error(\"promise catch \"+err); } However, when I say await will wait for the fulfillment or rejection of a promise, you should be aware that in JavaScript, blocking is generally undesirable. JavaScript has only one thread, and when that single thread is blocked, the whole program is blocked and cannot process any network services or interaction in user interface. The example p123.mjs demonstrates an exception, not a norm, of JavaScript. You can use await on the top-level statements, which may block the single thread. However, you cannot block the event loop.\nJavaScript does not allow you simply use await inside a ‘normal’ function. You can only use await inside a function that is marked as async (asynchronous).\n// p126.mjs import { readFile, writeFile } from 'fs/promises'; async function copyFile (sourceFileName) { try { let data = await readFile(sourceFileName, 'utf8'); await writeFile('copy-' + sourceFileName, data, 'utf8'); console.log(\"Finish copying\"); } catch (err) { console.error(\"promise catch \"+err); } } await copyFile('mpi-info.txt'); Essentially, async function returns a promise object. It may take a long time to finish running the function, but when it returns, it can return a value (i.e. result). If an exception is thrown inside an async function, the function stops execution, and the returned promise object is rejected with the exception object. The following example rewrites p126.mjs to illustrate this.\n// p127.mjs import { readFile, writeFile } from 'fs/promises'; async function copyFile (sourceFileName) { let data = await readFile(sourceFileName, 'utf8'); await writeFile('copy-' + sourceFileName, data, 'utf8'); } copyFile('mpi-info.txt').then( () =\u003e { console.log(\"Finish copying\"); }).catch(err =\u003e { console.error(\"promise catch \"+err); }); Further reading  Chapter 11 in the Modern JavaScript tutorial: Promise MDN Chapter on Asynchronous JavaScript MDN article, Using promises  Downloadable examples The example source files are available here.\n",
    "description": "",
    "tags": null,
    "title": "4-3 Promise, await and async",
    "uri": "/4server/4-3/"
  },
  {
    "content": "Conditional rendering You can determine which part of the template to display depending on the value of data properties. Vue provides directives v-if, v-else-if and v-else to select what HTML content to show. The excerpt from example p304.html displays different message based on the value of temperature and rain.\n\u003cdiv id=\"app\"\u003e \u003cdiv\u003eTemperature: {{ temperature }}°C \u003cspan v-if=\"temperature\u003e=25\"\u003eIt's hot!\u003c/span\u003e \u003cspan v-else-if=\"temperature\u003e=10\"\u003epleasant weather\u003c/span\u003e \u003cspan v-else\u003eIt's cold, stay warm\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003eRain: {{ rain }}% \u003cimg v-if=\"parseFloat(rain)\u003e=30\" src='image/umbrella.png'\u003e \u003c/div\u003e \u003c/div\u003e \u003cscript\u003e const weather = { data() { return { temperature: 28, rain: 10 } } }; const vm = Vue.createApp(weather).mount('#app'); \u003c/script\u003e Refer to the online reference for more detail of v-if and other conditional rendering directives.\nList rendering When you want to display a list of content, you often group the content in an array in the data property, and use the directive v-for to repeat some HTML code for each item in the list. The example p305.html below shows an array of string values using a sequence of \u003cspan\u003e elements.\n\u003cdiv id=\"app\"\u003e \u003cp v-if=\"sport.length===0\"\u003eI don't really like sports\u003c/p\u003e \u003cp v-else\u003eMy favorite sports: \u003cspan v-for='x in sport' class='box'\u003e{{ x }}\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003cscript\u003e const hobby = { data() { return { sport: [ 'football', 'running', 'swimming' ] } } }; const vm = Vue.createApp(hobby).mount('#app'); \u003c/script\u003e For more detail of list rendering and the directive v-for, refer to the online reference.\nThe example p306.html use v-for to display an array of objects using HTML table.\n",
    "description": "",
    "tags": null,
    "title": "3-3 Dynamic structure in template",
    "uri": "/3client/3-3/"
  },
  {
    "content": "This lab explains the basics of the JavaScript functions.\nFunctions There are two ways to define functions: the function keyword and arrow functions. This lab covers the first. We use a function to group some statements that can be reused.\n// draw a right angle triangle of height n function draw (n) { let out = \"\" for (let y=0; y\u003cn; y++) { let s = \"\" for (let i=0; i\u003cn-y-1; i++) s += \". \" for (let i=0; i\u003c=y; i++) s += \"* \" out += s+\"\\n\" } console.log(out) } draw(5) // call the function to draw a triangle of height 5 draw(10) // draw again Functions can return values to the calling code with return. The return statement also ends the execution of the functions immediately.\n// this function compares the two parameters a and b, and returns the bigger one function bigger (a,b) { if (a\u003eb) { return a } else { return b } } console.log('The bigger one is ', bigger(2,3)) // another way to write function bigger2 (a,b) { if (a\u003eb) { return a } return b } // yet another way to write function bigger3 (a,b) { return a\u003eb ? a : b } The next example defines a function that finds the largest number in an array, assuming that the array has at least 1 element.\nfunction max (num) { let x = num[0] // assume the 0th element is the largest  // compare x with each remaining element  for (let k=1; k\u003cnum.length; k++) { if (num[k]\u003ex) x = num[k] } return x } max([2,3,5,8,7,1,4,6]) // return 8 Variable scope In JavaScript, variables defined inside a function are called local variables. They are visible from the point of declaration up to the end of the function. When you call a function, all its local variables are created; when the function returns (stops execution), the local variables are destroyed.\nfunction foo (param1, param2) { // 'a' cannot be used yet, but 'param1' can be used here  // ...  let a = 4; // ...  // 'a' can be used till the end of the function  console.log(a); }  Technical note: Sometimes, a local variable may still exist after the function that defines it returns. This is the case if the variable falls into the closure of an inner function which is returned by the outer function. See online reference for more information.\n Variables defined using let or const may further be restricted to a block scope. A block is a region of the function then is delimited by { }. This works similarly to Java’s scoping rules.\nfunction bar () { for (let i=0; i\u003c10; i++) { /* 'i' can be used only within this block */ } while (Math.random()\u003c0.5) { let k; /* the scope of 'k' is this 'while' loop */ } } On the other hand, variables defined outside any functions are global variables, and are visible in any functions. It is generally recommended to use global variables as little as possible.\nExercise   Write a function sum(num) to calculate the sum of elements in an array num. Use the following code to test your function.\nlet x = [1,2,3,4,5]; let ans = sum(x); console.log('Correct? ', ans==15);   Write a function odd(n) to generate an array of odd numbers less than or equal to n. Test your function with the following code.\nlet a = odd(1); console.log(a); // should print [1] console.log(odd(9)); // should print [1,3,5,7,9] console.log(sum(odd(10*2-1))); // should print 100   Write a function search(num, n) to search for an number n in the array num. Return the position of the element if it is found. If it is not found, return -1. Test your function with the following code.\nlet x = [6, 8, 3, -2]; console.log(search(x, 3)); // should print 2; console.log(search(x, 1)); // should print -1;   The sample answers are available at ex2-3q1.js, ex2-3q2.js and ex2-3q3.js respectively.\n",
    "description": "",
    "tags": null,
    "title": "2-3 Functions",
    "uri": "/2basic/2-3/"
  },
  {
    "content": "Client-side programming This chapter goes through the basics of the JavaScript programming inside the Web browser environment.\n 3-1 Background  Document tree manipulation vs. MVVM approach   3-2 Vue basics  Loading Vue library from CDN Data properties and reactivity Template syntax: moustache {{ }}, attribute binding v-on:attr, style binding Computed properties   3-3 Dynamic structure in template  Conditional rendering: v-if and others List rendering: v-for   3-4 Events, methods and component lifecycle  asynchronous function calls UI event handling, @event Component methods JavaScript timers, setInterval, setTimeout Component lifecycle hooks, created and others   3-5 Forms controls and bi-directional binding  Using HTML built-in form controls v-model and bi-directional binding   3-6 Components: motivation and common features  reuse components organize a web app as a hierarchy of components properties / attributes, event, v-model, slots   3-7 Vue projects and build tools  intro to Node.js, node project, package.json Vite, build tools Starter project and SFC   3-8 Defining your own components  define prop bi-directional binding emit event    Here are some useful online reference for this chapter.\n Vue.js official site: guide and API reference for Vue 3 Node.js official site NPM registry, the largest JavaScript library registry The build tool Vite that we use in second half of the chapter  Todo: multiple html, public folder in Vite\n",
    "description": "",
    "tags": null,
    "title": "Client-side programming",
    "uri": "/3client/"
  },
  {
    "content": "In a modern web app, client-side JavaScript programs react to user interaction, and send HTTP requests to Web APIs to get up-to-date information to display or invoke actions on the server. Client-side programs also need to handle receive data or reported errors from the server.\nWeb browsers provide two main means to send asynchronous HTTP requests: the traditional XMLHttpRequest, and the new Fetch API. XMLHttpRequest applies callbacks and events to handle asynchronous message handling, while the Fetch API fetch is based on promises. In this chapter, we’ll use fetch to interact with Web APIs.\nMaking GET requests An introduction to fetch() usually starts with an example that resembles the following. Line 3 assumes the response body is JSON format, and converts it to JavaScript data. Line 4 receives the data, and prints it in the console. The default HTTP method fo fetch() is GET.\nconst endpoint = 'https://jsonplaceholder.typicode.com/users/1'; fetch(endpoint) .then((response) =\u003e response.json()) .then((json) =\u003e console.log(json)); You can rewrite the above example using await, as below. This work inside an async function, or on top level of a program.\nconst endpoint = 'https://jsonplaceholder.typicode.com/users/1'; let response = await fetch(endpoint); let json = await response.json(); console.log(json);  A GET request cannot have payload in the body. So you can only attach payload in the query string of the URL. For example, some REST APIs enhance the endpoints of collection resources to accept search criteria. The following endpoint retrieves the pending todo of the user with userId=1.\nhttps://jsonplaceholder.typicode.com/todos?userId=1\u0026completed=false\nYou can construct the query string in the end of the URL yourself, or you can use the browser built-in object URLSearchParams to do the encoding.\nconst endpoint = 'https://jsonplaceholder.typicode.com/todos?' + new URLSearchParams({ userId: 1, completed: false, }); fetch(endpoint) .then((response) =\u003e response.json()) .then((json) =\u003e console.log(json)); Understanding the two ‘then handlers’ The first example of fetch() above involves two promises.\nThe browser built-in function fetch() initiates an HTTP request and returns a promise. Because it will take some time until the browser receives the response, fetch() is asynchronous. The promise will resolve to a response object when the browser has received the status line and headers of the response, but before it receives the full response body. The promise rejects if there are network errors. You can check response.ok to find whether the HTTP status code is in class 200, e.g. 200 Ok or 204 No content.\nconst endpoint = 'https://jsonplaceholder.typicode.com/users/1'; fetch(endpoint).then((response) =\u003e { console.log('ok: ', response.ok, 'status: ', response.status); console.log('headers: ', [...response.headers]); // but the response body is not yet ready yet }) Assuming that the response is ok, you can call the method response.json() to read the response body, treat it as JSON string, and convert it into a JavaScript object. (Attention!) This method also returns a promise. (Some response body may be large and will take some time to transfer from the server.) The promise resolves to a JavaScript object when the JSON data is ready.\nconst endpoint = 'https://jsonplaceholder.typicode.com/users/1'; fetch(endpoint).then( (response) =\u003e { let prom = response.json(); prom.then( (json) =\u003e { // 'json' is a JavaScript object converted from the JSON payload  console.log(json); }); }); The ‘then handler’ only creates a promise and handles it. We can take advantage of chaining ‘then handlers’ of a promise to simplify the code. If the ‘then handler’ returns a new promise, you can chain the ‘then handler’ of the new promise.\nconst endpoint = 'https://jsonplaceholder.typicode.com/users/1'; fetch(endpoint) // this handler returns a promise that resolves to json data  .then((response) =\u003e response.json()) // this handler receives the json data  .then((json) =\u003e console.log(json));  fetch() does not reject if the server returns an HTTP status code reporting errors (e.g. 404, 500). For example,\nfetch('https://httpstat.us/500').then( (response) =\u003e { console.log('ok: ', response.ok, 'status: ', response.status); console.log('headers: ', [...response.headers]); console.log('url: ', response.url); }).catch( (error) =\u003e { console.log('promise rejected: ', error); }); fetch() rejects when there is network error, or somehow it cannot finish the HTTP request-response transaction. For example,\nfetch('https://notexist.ipm.edu.mo').then( (response) =\u003e { console.log('ok: ', response.ok, 'status: ', response.status); }).catch( (error) =\u003e { console.log('promise rejected: ', error); }); In general, you can handle erroneous HTTP status code by throwing an Error object. Next, you attach a ‘catch handler’ at the end of the chain of ‘then handlers’. The ‘catch handler’ will handle promise rejections and exceptions thrown in the ‘then handlers’.\nconst endpoint = '...'; fetch(endpoint).then( (response) =\u003e { if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); }).then( (json) =\u003e { // process the json data  console.log(json); }).catch( (error) =\u003e { console.log('promise rejected: ', error); }); Refer to https://css-tricks.com/using-fetch/ for more explanation on error handling in fetch.\n Making other requests fetch() has a second parameter that allows you to set the HTTP verb (e.g. method: 'POST') and message body. Notice that you need to format your data as a JSON string using JSON.stringify(), and set the Content-type header manually. The following example sends a POST request to the testing endpoint to create a new post.\nconst content = { userId: 1, title: 'foo', body: 'bar' }; fetch('https://jsonplaceholder.typicode.com/posts', { method: 'POST', body: JSON.stringify(content), headers: { 'Content-type': 'application/json', }, }) .then((response) =\u003e response.json()) .then((json) =\u003e console.log(json)); The code used to send PUT, PATCH and DELETE are similar. You can find some examples in https://jsonplaceholder.typicode.com/.\n If you need to send URL-encoded payload in request body, use URLSearchParams. For example,\nfetch('https://example.com/products.create', { method: 'POST', body: new URLSearchParams({ productName: \"Great new chocolate\", category: \"Confections\", unitPrice: 20, unitsInStock: 100 }) }).then(response =\u003e { // handle the response });  Sample program The sample program p540-fetch implements the client side of a web app. Download the project and uncompress the project. Install and run the project as follows.\n$ npm install # build the client side of the web app to ./dist $ npm run build # run the web api server $ node server.mjs You can now access the web app at http://localhost:8000/ . The web API is accessible at http://localhost:8000/api .\nFurther resources Fetch API\n https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch The chapter on Network requests in javascript.info covers more detail of the Fetch API. In addition, it also discusses XMLHttpRequest and WebSocket. charset is not required after application/json. https://newbedev.com/what-does-content-type-application-json-charset-utf-8-really-mean The Fetch API is natively supported by modern web browser, but is not included in Node.js. However, there are package like node-fetch which provides most of its feature in Node.js.  Testing APIs:\n https://reqres.in/ and https://jsonplaceholder.typicode.com/ provide REST APIs with sample data. But they don’t persist changes from POST, PUT and DELETE requests. https://dummyapi.io/ includes more kinds of data, and support persisting changes. But it requires registration to get an app_id.  ",
    "description": "",
    "tags": null,
    "title": "5-4 Making HTTP requests in client",
    "uri": "/5appserver/5-4/"
  },
  {
    "content": "When you build a complicated program, it becomes necessary to break your source code into multiple files called modules for better management and organization. In addition, you’ll often want to take advantage of other’s work and use third-party modules, e.g. install a package from https://npmjs.org. To support these, JavaScript allows programmers to export some functions / variables from a module, and import some functions / variable in another module.\nIn the JavaScript world (Browsers, Node.js, etc), there are two common ways to organize features from a module.\n import individual function / variable from a module, as required. import the whole module as an object  Named export and import Suppose that you want to write a board game in JavaScript, and you’ve found a module dice-util.mjs that provides some useful function for rolling dice. From their documentation, you pick two particular functions named rollDice and rollDiceSum which the module export. You import the two functions in the following ways.\n// p131.mjs import { rollDice, rollDiceSum } from './dice-util.mjs'; let sixDice = rollDice(6, 10); console.log(`Roll six dice of 10 faces and get ${sixDice}.`) let diceSum = rollDiceSum(10, 6) console.log(`Roll 10 dice of 6 faces and their sum is ${diceSum}.`);  In this example, the module name is a (relative) path to a JavaScript module file in the same folder as p131.js. Different platforms (e.g. browsers and Node.js) provide different ways to locate modules. For Node.js, we can use relative or absolute path to specify a file.\n How does the author of the module dice-util.mjs indicate which functions to export? One simple way is to attach the keyword export in front of the definition of the functions.\n// dice-util.mjs  // internal function, not exported function randomInteger(min, max) { return Math.floor(Math.random()*(max-min+1))+min } export function rollDice (count, face) {  // assume count \u003e 0, face \u003e 1, integers  let result = [ ]; for (let n=0; n\u003ccount; n++) { result.push(randomInteger(1,face)); } return result; }  Alternatively, you can specify the functions to export with a statement like export { rollDice, rollDiceSum }.\n Named export is only supported by ES Module, a new standard of JavaScript module system that can be used on both client-side (web browsers) and server-side (Node.js). Therefore, existing modules may have limited support for named exports.\nOther ways to use modules We’ve seen some uses of import in previous lectures. For example, in last section, we imported some function from the Node.js built-in fs module.\n// p127.mjs import { readFile, writeFile } from 'fs/promises'; async function copyFile (sourceFileName) { let data = await readFile(sourceFileName, 'utf8'); await writeFile('copy-' + sourceFileName, data, 'utf8'); } // ... We can also import from modules in client-side development. For example, in Chapter 2, we used named import and export to load components from a UI library. Before we can import from the module element-plus, we’ve to install it into the current project by npm install. This import statement is handled by the code bundler in the Vite build tool.\n// import \u003cel-button\u003e and \u003cel-input\u003e from ElementPlus import { ElButton, ElInput } from \"element-plus\"; You can also use named exports from third-party package from NPM. For example, the following example uses two functions from the Math.js package. You need to install the package before running the program. (e.g. with npm install mathjs)\n// p132.mjs import { evaluate, inv } from 'mathjs'; console.log(`sqrt(-1) = ${evaluate(\"sqrt(-1)\")}`); console.log(`sqrt(i) = ${evaluate(\"sqrt(i)\")}`); const mat = [ [1,2], [3,4] ]; console.log(\"A matrix: \", mat) console.log(\"and its inverse: \", inv(mat)); As a summary, there are several ways you can use modules in Node.js\n use built-in modules in Node.js, and import using a “bare module name” install a package from NPM registry using the command npm install package_name, and import using a “bare module name” write the module yourself, and import using a path to the module file  You can also use modules in client-side programming.\n use a package manager (e.g. npm) to install modules in project folder, and a build tools (e.g. Vite) to bundle all JavaScript code for the client-side of your web app in one (or a few) JavaScript script file. The HTML file will then load this bundle file. modern browsers have native support for ES modules, so it’s possible to use modules without build tools. See the advanced example p331-module-in-browser for a Vue component example. For more information on browser support of modules, refer to online reference.  Default export The other common way to use modules is to import a module as one module object. This is common in module systems before ES module, e.g. the CommonJS standard in traditional Node.js packages.\nWe can specify a default export with the default keyword. You can export a function, a class or a variable using export default, and you don’t give it a name. In many cases, you want to group several thing in a module object, as export it as default. This is demonstrated in the following example.\n// circle.js  class Circle { constructor (x, y, radius) { /* omitted */ } area () { /* omitted */ } /* more methods */ } function contains (c1, c2) { /* detail omitted */ } // make a default export module object which contains the class and the function export default { Circle, contains } To use this module, import it into a module object as follows. Notice that we don’t use { }, and we can choose an arbitrary name for the module.\n// p133.mjs import cc from './circle.mjs' let c = new cc.Circle(1,2,10); let a = c.area(); We’ve also used similar syntax to import a built-in module in Node.js, for example …\n// p103.mjs // show basic info about CPU and memory import os from 'os'; let cpus = os.cpus(); console.log(`CPU: ${cpus[0].model}, ${cpus.length}core`); console.log(`Total memory: ${os.totalmem()/1024**3}G`); and import a module downloaded from https://www.npmjs.com/package/systeminformation .\n// p104.mjs import si from 'systeminformation'; si.cpu() .then(data =\u003e console.log(data));  Note: some modules support both named export and default export. e.g. both import fs from 'fs/promises' and import { readFile } from 'fs/promises' work.\n Load CommonJS modules with import Before the introduction of the ES module standard, Node.js uses CommonJS modules. Many JavaScript Node.js packages were published in CommonJS format, and existing books and online tutorials often use this traditional JavaScript module format. Commonly, code examples uses statement like let fs = require('fs') to import a CommonJS module. The module is imported as a module object, and saved in the variable fs. You may then access functions using dot notation, e.g. fs.readFile.\nIn ES module script (extension *.mjs), you cannot use require. Instead, you can import a CommonJS module as a module object in a similar way as in importing default export. For example, you can rewrite let prompts = require('prompts') as import prompts from 'prompts'. The following example uses two packages prompts and figlet from npmjs.org.\n// p134.mjs import prompts from 'prompts'; import figlet from 'figlet'; prompts({ type: 'text', name: 'sentence', message: 'Type a short sentence' }).then( data=\u003e { figlet(data.sentence, function(err, data) { if (err) throw err; console.log(data) }); }); Default export from Vue SFC We also used default export when we write a Vue SFC (Single File Component). In fact, build tool like Vite converts each SFC (*.vue) into a JavaScript module which export the options object of the component.\n\u003ctemplate\u003e The time now is \u003cdiv class='clock'\u003e{{ timeNow }}\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { timeNow: undefined } }, created() { /* omitted */ } }; \u003c/script\u003e For example, the file MyClock.vue above is translated into a JavaScript module similar to MyClock.mjs below. (The actual process is more complicated, e.g. the template will be compiled into a render function.)\nexport default { data() { return { timeNow: undefined } }, created() { /* omitted */ }, template: `The time now is \u003cdiv class='clock'\u003e{{ timeNow }}\u003c/div\u003e` }; Downloadable examples The example source files are available here.\n",
    "description": "",
    "tags": null,
    "title": "4-4 Modules, import and export",
    "uri": "/4server/4-4/"
  },
  {
    "content": "This section discusses several kinds of asynchronous function calls in client-side programming. We define these asynchronous functions in the program, but our code does not call them directly. Instead, we registered these asynchronous functions to handle some future events, e.g. user interface events, timers and Vue component life cycle.\nUI event handling In a web app, a common way to trigger an action is mouse click. When a user clicks on an HTML element, the element is said to fire a click event. We can use the Vue directive v-on:click (or shorthand notation @click) to define an event handler. Look at the code snippet from the example p307.html.\nThe event handler can be a JavaScript statement, (e.g. count++) or the number of a method of the view model.\n\u003cdiv id=\"app\"\u003e \u003cp\u003eClick count: {{ count }}\u003c/p\u003e \u003cbutton class='btn btn-primary' v-on:click='count++'\u003eAdd 1\u003c/button\u003e\u0026nbsp; \u003cbutton class='btn btn-success' @click='this.count--'\u003eMinus 1\u003c/button\u003e\u0026nbsp; \u003cbutton class='btn btn-warning' @click='reset'\u003eReset to 0\u003c/button\u003e\u0026nbsp; \u003c/div\u003e \u003cscript\u003e const opts = { data() { return { count: 0 } }, methods: { reset(event) { this.count = 0; // check the event object in browser console ...  } // another method omitted  } }; const vm = Vue.createApp(opts).mount('#app'); Vue component methods are defined under the methods property of the options object. Inside the method body, you can use this to refer to data properties. Examine the view model vm in browser’s developer tools to check that both data properties and methods are properties of vm.\n Vue component method definition cannot use arrow function, because it requires this.\n Timer JavaScript timers allow us to schedule a function to run after a certain time period. There are two types of timers. One-time timer will run a given function once after a fixed period, and periodic timer will run a given function repeatedly with an interval of a fixed period. (online reference)\n// set a timer of 5s. show a message when timer expires let timerId = setTimeout( ()=\u003e{ console.log('Time is up') }, 5000 ); // run this to cancel the timer because it expires clearTimeout(timerId); // set an interval timer of 2s. show a message every 2s let timerId = setInterval( ()=\u003e{ console.log('2s passed') }, 2000 ); // run this to cancel the timer clearInterval(timerId); Study the example p307-timer.html for another example of timers.\nLife cycle methods Another source of asynchronous function calls in Vue is lifecycle hooks.\nExamples we studied up to this moment only apply a single component instance, which is the root component mounted to the document tree. (In later sections of this chapter, we’ll learn how to define new components and use third-party components.) Each component instance will go through several moments in its lifecycle. These include created, mounted, updated and unmounted. By defining a lifecycle hook in the options object, we can instruct Vue what to do in different moments in the lifecycle.\nClick here to see the Vue component lifecycle diagram.\nFor example, we can define a created hook to initialize a component after its data properties are created, but before its template is processed and mounted to the document tree. For example, you can load data from a server to populate the initial view of a component.\nThe following code snippet comes from example p307-lifecycle.html.\n\u003cdiv id=\"app\"\u003e \u003cp\u003eThis component is created {{ count }} seconds ago.\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e const opts = { data() { return { count: 0 }; }, created() { setInterval( ()=\u003e{this.count++}, 1000 ); }, updated() { console.log(\"component updated...\"); } } \u003c/script\u003e ",
    "description": "",
    "tags": null,
    "title": "3-4 Events, methods and component lifecycle",
    "uri": "/3client/3-4/"
  },
  {
    "content": "This lab covers the basics of JavaScript objects and how to model complicated data using arrays and objects. The resultant data structure forms the basis of the JSON data format.\nObjects In JavaScript, an object is a collection of properties. Each property is a pair of name and value. (Sometimes JavaScript objects are used as key-value stores.) You can access each property with the dot notation.\n// define an object with 3 properties let peter = { firstName: \"Peter\", lastName: \"Chan\", age: 19 }; console.log(peter.lastName); // \"Chan\" peter.age ++; console.log(`${peter.firstName}is now ${peter.age}years old.`); Use assignment to change the value of an existing property, or add a new property.\nlet point = { }; // empty objects point.x = 10; // add property point.y = 8; dir(point); // show structure, only avail in Chrome console JavaScript objects are also a reference data type. (We mentioned in last section that arrays are reference data type.) When you assign an object variable to another variable, both variables will refer to the same object.\nlet p1 = { x: 10, y: 8, }; // adding a comma after the last property is ok let p2 = p1; p2.x = 3; console.log(p1); // p1 and p2 refer to { x: 3, y: 8 } Functions can accept objects, and return objects. In the following, objects with the two properties x and y represent points on a plane.\nfunction distance (p1, p2) { // the function Math.hypot() can also be used here  const sum_sqr = (p1.x-p2.x)**2 + (p1.y-p2.y)**2; return Math.sqrt(sum_sqr); } function midpoint (p1, p2) { // create an object with properties x and y, and then return the object  return { x: (p1.x+p2.x) / 2, y: (p1.y+p2.y) / 2 }; } let p1 = { x: 0, y: 0 }, p2 = { x: 3, y: 4 }; console.log(`Distance = ${distance(p1,p2)}`); let mid = midpoint(p1, p2); console.log(mid); Complicated data We can put an object as a property of an object.\nlet author = { firstName: 'Philip', lastName: 'Lei' }; let book = { title: 'Principles of gaming technology', author: author, // a shorthand for this line is 'author,'  publisher: 'McGraw Hill' }; console.log(`The textbook of comp414 is ${book.title}, of which one of the authors is ${book.author.firstName}.`); We can also put objects as elements in an array, or put an array as a property of an object. This representation can model complicated data.\nlet lecturesOfComp312 = [ { dow: 1, start: 1430, end: 1600, room: 'A210' }, { dow: 5, start: 1130, end: 1300, room: 'A114' } ]; let comp312 = { code: 'comp312', title: 'Internet programming II', year: 3, lectures: lecturesOfComp312 }; const dowName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ]; console.log(`The lectures of '${comp312.title}' are on ${dowName[comp312.lectures[0].dow]}and ${dowName[comp312.lectures[1].dow]}`); Destructuring and spread syntax A recent feature called destructuring assignment makes it convenient to extract values from objects.\nlet book = { title: 'Principles of gaming technology', authors: [ 'Philip', 'Andrew' ], publisher: 'McGraw Hill', isbn13: '978-981-4923-23-1' }; let { title, publisher, ...others } = book; console.log(`Book title is ${title}.`); // others keeps properties other than 'title' and 'publisher'  // you can also extract nested data let { title, authors: [a1, a2] } = book; The spread syntax ...object also allows to copy content of one object into another.\nlet p1 = { x: 2, y: 3 }; let p2 = { ...p1, z: 0 }; // convert the point on plain to a point in 3D space A note on object notation In addition to the dot notation, you can also use array notation to access a property in objects. Recent update to JavaScript also allows some non-ASCII characters in property names. (But property names cannot start with a digit.)\nlet cn2en = { 春: 'spring', 夏: 'summer', 秋: 'autumn', 冬 : 'winter' }; cn2en['春'] // 'spring' cn2en.春 // also works The JavaScript language also has a for .. in control structure to enumerate the properties of an object. We skip its discussion because it is tricky to use.\nExercise By mixing arrays and objects, you can use represent some complicated data. This forms the basis of the JSON data format.\nIn the following example, the object timetab represents the lecture timetable for 2016/17, semester 1. The property courses has array value, and contains an object for each course.\nconst timetab = { acadYear: \"2016/17\", semester: 1, courses: [ { code: 'comp211', title: 'Database design', year: 2, lectures: [ { dow: 2, start: 1130, end: 1300, room: 'A203' }, { dow: 4, start: 1000, end: 1130, room: 'A318' } ] }, { code: 'comp212', title: 'Programming II', year: 2, lectures: [ { dow: 4, start: 1430, end: 1600, room: 'A317' }, { dow: 3, start: 1600, end: 1730, room: 'A210' } ] }, { code: 'comp214', title: 'Computer networks', year: 2, lectures: [ { dow: 5, start: 1000, end: 1300, room: 'A206' } ] } ] }; Use the time table data structure above to complete this exercise. Refer to the sample answers for sample output: ex2-4q1.js, ex2-4q2.js and ex2-4q3.js.\n  Write a program to show the number of lectures of each course. The output should include course code, course title, and number of lectures per week.\n  Write a program to print the content of the time table.\n  Write a program to list the lectures on Thursday dow===4. The output should include course code, start and end time, and room.\n  ",
    "description": "",
    "tags": null,
    "title": "2-4 Objects as data structure",
    "uri": "/2basic/2-4/"
  },
  {
    "content": "Server-side programming This chapter goes through the basics of the JavaScript programming on the server side using Node.js.\n 4-1. Node primer  compare node.js and browser env event loop modules, NPM package.json semantic versioning   4-2. Asynchronous callback  asynchronous I/O operations event and event handlers sequential I/O operations   4-3. Promises  promises, state and result then and catch handlers chaining promises handling errors await and async   4-4. ES modules  modules: built-in, local, NPM named exports default export compatibility with CommonJS   4-5. Database access  sqlite SELECT, INSERT, UPDATE, DELETE    Here are some useful online reference for this chapter.\n https://nodejs.org: official site of Node.js, and the API reference Tutorial on Node.js: cover key concepts and built-in modules of Node.js Advanced JavaScript concepts covered in this chapter  Chapter 11 in the Modern JavaScript tutorial: Promise MDN article, Using promises MDN Chapter on Asynchronous JavaScript Error handling, including exception handling Modules, MDN Modules in Modern JavaScript tutorial    ",
    "description": "",
    "tags": null,
    "title": "Server-side programming",
    "uri": "/4server/"
  },
  {
    "content": "This lab demonstrates basic database programming in Node.js using a file-based database sqlite.\nSQLite SQLite is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine (from https://www.sqlite.org/). The whole database is stored in a file, and an application can open this database directly without connecting to any server.\nA popular module to access SQLite in Node is sqlite3. However, this module only provides a callback-based API. Therefore, we will also use the package sqlite which is a wrapper library on sqlite3 that provides a promise-based API. (online reference)\nThe package.json in the example code already include the following dependencies. You can install both packages using npm install.\n\"dependencies\": { \"sqlite\": \"^4.0.23\", \"sqlite3\": \"^5.0.2\" }, The example code zip file also includes a sample database my-northwind.sqlite, which is based on a sample database for Microsoft SQL server. I’ve converted it into SQLite format. You can read the database schema here.\nTo browse the content of the database, install and use the GUI tool DB browser for SQLite.\nRetrieve data with SELECT SQLite supports both basic and advanced features of SELECT statements. The following demonstrates the steps to read data from a database.\nMost functions of sqlite are asynchronous. In other words, they return a promise which may either resolve to the result (e.g. result set returned by SELECT), or reject with an error. For brevity, we use await on the top-level in the following example.\n// p141.mjs // import sqlite3 driver import sqlite3 from 'sqlite3'; // import database open function import { open } from 'sqlite'; // connect to the database system, open database file const db = await open({ // the database file  filename: './my-northwind.sqlite', // tell sqlite to use the standard 'sqlite3' driver  driver: sqlite3.Database }); const query = \"SELECT * FROM Product WHERE Id=14\"; // get a single row from the result set of the query const tofu = await db.get(query); console.log(tofu); // close the database connection await db.close(); db.get(query) returns one row from the result set of running the query. The row is formatted as a JavaScript object. (What if the SQL returns 0 or more than 1 rows?)\nIf you want to fetch all rows of the result set, you can either\n fetch all rows as an array of objects register a callback to handle each row one by one  This example demonstrates the first approach. db.all() returns a promise which resolves to an array of objects, in which each object corresponds to one row in the result set. This example also illustrates placeholders in SQL queries, column renaming, and using template strings to write multi-line SQL queries.\n// p142.mjs // The total sales quantity of products in category 7 - Produce // ... const query = `SELECT P.id as id, P.ProductName as productName, SalesQuantity FROM Product as P JOIN (SELECT ProductId, SUM(Quantity) as SalesQuantity FROM OrderDetail GROUP BY ProductId) as D ON P.id = D.ProductId WHERE P.CategoryID = $categoryId ORDER BY SalesQuantity DESC`; const productTotalSales = await db.all(query, { $categoryId: 7 }); console.log(productTotalSales); // ... The next example p143.mjs retrieves the orders (from Order table) made during December of 2012, and also calculates the total order amount from data in OrderDetail table for each order. We perform this task with two SQL select queries: one for retrieving orders, and one for calculating the total order amount for each order.\n// p143.mjs // ... async function getXmasOrders () { const queryOrders = `SELECT Id as id, OrderDate as orDate FROM 'Order' WHERE orDate BETWEEN $startDate AND $endDate`; const xmasOrders = await db.all(queryOrders, { $startDate: \"2012-12-01\", $endDate: \"2012-12-31\" }); for (let ord of xmasOrders) { ord.amount = await getOrderAmount(ord.id); } return xmasOrders; } const xmasOrders = await getXmasOrders(); console.table(xmasOrders); When we refactor the statements to a function to get the xmas orders, we have to make the function a async function because we’re using await inside. This function returns a promise. If the function returns a result (return xmasOrders), the promise resolves to that result (i.e. an array of order records). On the other hand, if any exception is thrown inside the function, including a rejection from await getOrderAmount(), the promise rejects with the error object of the exception.\nGetting the whole record into an array is convenient with db.all(). However, if the number of records is very large, and you only need to process the records one by one, you can avoid wasting system memory by using db.each(). This method calls a callback to process each row in the result set, and the returned promise resolves to the number of rows after all rows are processed.\n// p144.mjs async function exportOrderDetail () { const queryOrderDetail = `SELECT * FROM OrderDetail LIMIT 500 OFFSET 1000`; const prom = db.each(queryOrderDetail, {} , (err, row) =\u003e { if (err) throw err; console.log(row); }); // returns number of records in result set  return await prom; } const recordCount = await exportOrderDetail(); console.log(\"count =\", recordCount); INSERT, UPDATE and DELETE Use the method db.run() to execute INSERT, UPDATE and DELETE statements. In the callback to this method, the property this.changes indicates the number of rows affected by the query, and the property this.lastID contains the value of the last inserted row ID.\n// p145.mjs async function createCustomer (cust) { const query = `INSERT INTO Customer (CompanyName, ContactName, City, Phone) VALUES ($companyName, $contactName, $city, $phone)`; const result = await db.run(query, { $companyName: cust.companyName, $contactName: cust.contactName, $city: cust.city, $phone: cust.phone }); return result; } const insResult = await createCustomer({ companyName: 'MPI', contactName: 'Peter Chan', phone: '(853) 85996123', city: 'Macao' }); // insResult.lastID gives the primary key 'id' auto-generated by sqlite console.log('A new customer is created by SQL INSERT'); console.log('insResult:', insResult); Downloadable examples The example source files are available here.\n",
    "description": "",
    "tags": null,
    "title": "4-5 Database access",
    "uri": "/4server/4-5/"
  },
  {
    "content": "App server development Built on top of the last two chapters, in this chapter, we study several additional concepts to build a full-stack web app.\n 5-1. Web API, concepts  endpoints, HTTP methods, path payload, URL-encoded, JSON   5-2. RPC Web APIs  GET - retrieve items POST - update items   5-3. REST Web APIs  Resources, collection CRUD operations HTTP methods: GET, PUT, PATCH, DELETE, POST searching, pagination, sub-resources   5-4. Making HTTP requests in clients  Fetch API Send GET request, with payload in query string Send other requests (e.g. POST, PUT), with JSON payload in body sample program: p540-fetch   5-5. Web app server  Express.js Routes, middlewares sample program: p550-express.zip   5-6. Implementing REST API  to do    ",
    "description": "",
    "tags": null,
    "title": "App server programming",
    "uri": "/5appserver/"
  },
  {
    "content": "Bi-directional binding with v-model HTML provides several form controls for text input and selection. You can make a bi-directional binding of a data property to the value of a form control using v-model directive. As a simple example, look at the following code. When a user inputs or changes text in the input control, the data property is updated immediately. Similar, when the data property name changes, the input control also refreshes with the update.\n\u003cdiv id=\"app\"\u003e \u003cdiv\u003eName:\u003c/div\u003e \u003cinput v-model=\"name\" /\u003e Hello {{ name }}! \u003c/div\u003e \u003cscript\u003e const opts = { data() { return { name: '' } } }; Vue.createApp(opts).mount('#app'); \u003c/script\u003e Please refer to the example p308.html for making bi-directional binding on various HTML form controls using v-model. If you employ a UI library with input control, the attributes used to configure the controls may be different. Please refer to their documentation, e.g. as in Element-Plus.\nThe example p309.html combines what’ve been covered so far.\n",
    "description": "",
    "tags": null,
    "title": "3-5 Form controls and bi-directional binding",
    "uri": "/3client/3-5/"
  },
  {
    "content": "Defining function objects Functions in JavaScript are often described as first-class values. (In fact, functions are objects, with their own properties and methods.) This means that, in many cases, if you can do something on numbers or strings, you can also do the same on functions. In particular, you can save a function in a variable, pass a function to another function, or return a function from a function.\nThere are three ways to define a function: function declaration, function expression and arrow function. We’ve introduced function declaration in section 2-2. (For more info, read reference.) The function name in a function declaration is a variable that refers to a function object. You can assign a function object to another variable, and call the function through that variable.\nfunction add (a,b) { return a+b; } add(1,2); // returns 3 console.log(add); dir(add); // shows the structure of the function object  // assign another name to the function let f = add; f(1,2); // returns 3. this is the same as add(1,2) // dir(f) The second way to define a function is function expression. The syntax of function expression is similar to that of function declaration, but function expressions appear in locations that the JavaScript language would expect a value, for example, the right side of an assignment, argument to a function call, and value in a JavaScript data structure (more about this in the next section.) Usually, we don’t provide a name in a function expression, and therefore sometimes it’s called an anonymous function.\n Technical note: It’s possible to provide a name for function expression. See reference for its use cases.\n // define a function object, and assign it to a variable let f = function (a,b) { return a+b } f(1,2); // returns 3  // define a function object, and call it immediately (function (a,b) { return a+b })(1,2); // returns 3  // define four functions for the arithmetic operators +, -, * and /. // store them in an array let op = [ function (a,b) { return a+b }, function (a,b) { return a-b }, function (a,b) { return a*b }, function (a,b) { return a/b } ]; // calculate 1+2*3 op[0](1, op[2](2,3)); // return 1+2*3 A recent update of JavaScript introduces a new way to define function objects, known as arrow functions. Similar to function expression, an arrow function produces a function object. However, arrow functions support a more concise syntax, and allow some further shorthand notation to write simple functions.\n Technical note: there is an important difference between arrow functions and function expressions on the handling of this, which we’ll explain in the next section. See mozilla reference for more differences between arrow functions and function expressions.\n // a function expression let f1 = function (a,b) { return a+b; } ; // the 'same' function, written as an arrow function let f2 = (a,b) =\u003e { return a+b; } ; // when the function body contains only a return statement, // you only need to write the function return value after the fat arrow let f3 = (a,b) =\u003e a+b; // when there is only 1 parameter, you can omit the parenthesis let f4 = a =\u003e a+1; Function objects as parameters and return values Passing a function object to another function is possible. Such usage is sometimes called callback: a programmer defines a callback function , but doesn’t write code to call the callback directly. Instead, some other code will call this function back. Callback can change the behavior of another function.\n// use a function op(x,y) to combine 3 values function combine (op, a, b, c) { const t = op(a,b); const ans = op(t,c); return ans; } // define an anonymous function, and save it in the const 'add' const add = function(a,b) { return a+b; } combine(add, 6, 7, 8); // returns 21  // define an arrow function for 'mul' const mul = (a,b) =\u003e a*b; combine(mul, 6, 7, 8); // returns 336 It is also possible to generate a function object, and return it from a function. In the following example, the function createRandomIntegerGenerator defines an arrow function that calculates a random integer in the range [min, max]. Notice that this arrow function can access the local variables min and max from its outer function. This is a useful feature of JavaScript called closure.\n// min and max are integers, min \u003c max // this function returns a function that returns a random integer between min and max inclusively function createRandomIntegerGenerator(min, max) { return () =\u003e Math.floor(Math.random() * (max - min + 1)) + min; } let tossDice = createRandomIntegerGenerator(1,6); tossDice(); // return a random number from 1,2,3,4,5,6 tossDice(); // return a random number from 1,2,3,4,5,6 Map and filter A common usage of callback functions is manipulation of a collection of data in containers like Array and Map (to be discussed later). In this sections, we demonstrate using several methods from Array objects, namely map, filter, reduce and sort.\nConsider the problem of performing some calculation on each element in an array, and collect the results as a new array.\nconst a = [1/2, 1/3, 1/4, 1/5, 1/6]; let b = []; // round the numbers to 2 decimal places for (let n of a) { let n2 = Math.round(n*100) / 100; b.push(n2); } // print a and b This is a common scenario in programming. Therefore, the Array objects provide built-in methods to iterate their content. One of the simplest is .map(), which accepts a callback function as a parameter. The callback function takes one input, performs some processing, and returns the result. .map() collects these results into an output array.\nfunction round2(n) { return Math.round(n*100) / 100; } const a = [1/2, 1/3, 1/4, 1/5, 1/6]; let b = a.map(round2); The callback function round2 is not called directly by your code. Instead, after definition, you pass the callback function to someone else’s code, and their code will call back your function later.\nconst a = [1/2, 1/3, 1/4, 1/5, 1/6]; // using an anonymous function expression as callback let b = a.map(function(n) { return Math.round(n*100) / 100; }); // using an arrow function as callback let c = a.map(n =\u003e Math.round(n*100) / 100); Another way to look at this is that a callback function can customize / modify the functionality of an existing function. For example, to calculate areas of rectangles in an array, we can write another callback function and pass it to .map(). This allows us to simplify an explicit for loop iteration …\n// an array of objects, each one is a rectangle with given width and height const rects = [ { w: 4, h: 5 }, { w: 2, h: 3 } ]; let areas = []; // calculate the area of the rectangles for (let k=0; k\u003crects.length; k++) { let area = rects[k].w * rects[k].h; areas.push(area); } … to a map method call with callback function.\n// using function expression let areas = rects.map(function (r) { return r.w * r.h; }); // or using arrow function let areas = rects.map(r =\u003e r.w * r.h); In addition to .map(), another popular iteration function in Array is .filter(). This function iterates the content of an array, and runs the callback function to determine whether to keep or discard each element. filter returns the selection as a new array. It does not modify the source array.\nlet emo = ['joy', 'sadness', 'anger', 'disgust', 'fear']; let emo2 = []; for (let s of emo) { if (s.length\u003c5) emo2.push(s); } // same as the for loop above // using function expression emo2 = emo.filter(function(s) { return (s.length\u003c5); }); // using arrow function emo2 = emo.filter(s =\u003e (s.length\u003c5)); Sorting JavaScript arrays have a built-in sort method. It can sort numbers and strings, but it does not know how to sort other objects.\nlet a = [5, 4, 1, 2, 3]; a.sort(); // a becomes [1,2,3,4,5] let b = ['apple', 'orange', 'banana']; b.sort(); // b becomes ['apple', 'banana', 'orange']  let p = [ { name: 'Peter', age: 10 }, { name: 'Mary', age: 9 }, { name: 'John', age: 11 } ]; p.sort(); // sort by name? by age? You can teach .sort() how to compare two objects with a callback function.\nlet p = [ { name: 'Peter', age: 10 }, { name: 'Mary', age: 9 }, { name: 'John', age: 11 } ]; // compare two persons by age function cmp (p1, p2) { if (p1.age\u003cp2.age) return -1; // p1 should be put before p2  if (p1.age==p2.age) return 0; // order not important  return 1; // p1 should be put after p2 } // sort by age p.sort(cmp); Exercise  Given an array let N = [ 32, 53, 42, 25, 48, 10 ], write a program to do the following. You should use callback functions. (sample answer)   Obtain an array of hexadecimal representation of the numbers in N. (Hints: use n.toString(16) to convert a number n to hexadecimal) Obtain an array of the numbers in N between 20 and 40 inclusively Count how many of the numbers in N are odd Calculate the sum of the numbers in N. Try to use .reduce() in Array. (online reference)  The variable comp312 is an array that contains records of student marks in the comp312 class. Each student record has three fields: name, test and exam. Write programs to do the following. Use an Array iteration method (i.e. .map(), .filter(), .reduce(), etc) at least once in each case. (sample answer) let comp312 = [ { name: 'Peter', test: 80, exam: 70 }, { name: 'John', test: 60, exam: 65 }, { name: 'Mary', test: 90, exam: 85 }, { name: 'Christine', test: 70, exam: 76 } ];  Get a list of student names in the comp312 class Get a list of student record with test mark \u003e= 75 Get a list of student name whose test mark is greater than exam mark Assume final mark = 0.6 * test + 0.4 * exam. Make an array with records showing the final mark and name for each student. Sort the list in descending order of exam mark Show the student record with the highest exam mark Calculate the average test mark    ",
    "description": "",
    "tags": null,
    "title": "2-5 Functions as objects and callbacks",
    "uri": "/2basic/2-5/"
  },
  {
    "content": "Express.js (official website) is a web framework to simplify development of Web applications. It supports:\n Routing – different request processing based on URL patterns Middleware – chainable processing of requests and responses Template – generate HTML output from variables  This lab covers how to define routes to capture HTTP requests for a web app / service endpoints. We’ll discuss how to generate simple HTTP responses. Finally, we’ll cover the usage of common middlewares.\nHandling requests at routes This example shows the basic structure of an Express app.\nimport express from 'express'; // create an Express application, which will handle HTTP requests var app = express(); // a route in the app, which handles GET request for the path '/' app.get('/', (req, res) =\u003e { res.send('hello world'); }); // more routes ...  // start listening at TCP port 3000 app.listen(3000); When a web app receives an HTTP request, it has to decide how to handle the request, and return the result as an HTTP response. Such decision usually depends on the HTTP method (e.g. GET, POST, PUT) and the path in the URL (e.g. “/about.html”). The combination of HTTP method and the URL path is usually referred to as an endpoint of the web app or web API.\nIn an Express app, we define a route to describe how to process HTTP requests at an endpoint. The general syntax is app.HTTP_method(path, callback), where HTTP_method stands for GET, POST, PUT, PATCH, DELETE, etc. The callback is sometimes called route handler, and can take 2 or more parameters. Often, we only use the first two parameters called req and res: req refers to the incoming HTTP request, and res is an object that is used to build the HTTP response. The following is a route for GET request at URL ‘/about.html’. The route returns a text response.\n// app is an Express app  app.get('/about.html', (req, res) =\u003e { // When the Express app receives a GET request  // for the path '/about.html', it returns a text response  res.send('This is a simple example of route') }); Some web apps include parameters in the URL path. You can easily extract these parameters in Express routes. Consider the sample code below, which shows a web app to check lecture hours. When the app receives a GET request for the path ‘/lecture/comp312’, it returns a response of its lecture hours. The parameters are available in the object req.params.\nCheck the source code of app1.mjs for more detail.\n// retrieve the lecture time app.get('/lecture/:code', (req, res) =\u003e { // in a real app, we'd query a database ...  if (req.params.code=='comp312') { res.send('Tue, Thu: 10:00-11:30am') } else if (req.params.code=='comp311') { // ...  } }) The above only describes the basics of routing in Express. Refer to the online guide for more possibilities.\nMaking responses You can use the res object in the route callback to build a response. (online reference) The res object has several common methods:\n  to set status code and headers\n res.status(code) sets the HTTP response code res.type(type) sets the Content-Type of the response res.append(field, [value]) appends a header with the given values res.cookie(name, value) sets a cookie    to send content in response body\n res.send(body) sends the response body. If body is a string, text/html is assumed. If body is a JavaScript object, the method converts it to a JSON string (JSON.stringify()) and use the Content type application/json. res.json(body) returns the data as JSON payload res.sendFile(path) returns a file as response. The method determines a suitable MIME type based on file type. res.redirect([status], path) redirects to the given URL res.end() usually used to send the response with an empty body    Some of these methods can be chained.\n// retrieve the lecture time app.get('/no-such-resource', (req, res) =\u003e { res.status(404).end() }) Check the source code of app2.mjs for demonstration of how to build responses with these methods.\nOrder of routes The order of routes is significant! An Express app checks the routes in the order they are defined. When a route matches the HTTP methods and URL path, the Express app executes its callback function to handle the request. The callback usually returns an HTTP response with res.send() or similar methods. When a response is returned, the Express app will stop checking the remaining routes. Once a response body is sent, it is said to have stopped the request-response cycle in Express. Express will not search the remaining routes (or middlewares) for the current request, and the processing of the request is completed.\napp.get('/lecture/comp312', (req, res) =\u003e { // special response for comp312  res.send('...'); }); // retrieve the lecture time app.get('/lecture/:code', (req, res) =\u003e { // search database, return a response  res.send('...'); }); app.get('/lecture/comp113', (req, res) =\u003e { // special response for comp113. But sorry, this route never runs!  res.send('...'); }); Handling URL-encoded payload Express decodes the query string of the request URL and deserializes it into a JavaScript object at req.query.\n// handle requests like GET /add?a=3\u0026b=5 app.get('/add', (req, res) =\u003e { let a = parseFloat(req.query.a); let b = parseFloat(req.query.b); res.json({ method: 'GET', a: a, b: b, sum: a+b }); }); To handle URL-encoded payload in request body, e.g. in POST requests, you need to let a middleware to do the decoding before the route to process the data. The middleware express.urlencoded deserializes the URL-encoded payload into a JavaScript object at req.body. (Similarly, there is a built-in middleware express.json to deserialize JSON payload.)\napp.use(express.urlencoded({extended: true})); app.post('/add', (req, res) =\u003e { let a = parseFloat(req.body.a); let b = parseFloat(req.body.b); res.json({ method: 'POST', a: a, b: b, sum: a+b }); }); Check the source code of app3.mjs for demonstration of how to build responses with these methods.\nMiddlewares In Express.js, both middlewares and route handlers are callback functions. When you set up an Express app, you register middlewares with app.use() and route handlers with app.get() (and also, for other HTTP method, e.g. app.post()) in sequential order to build a middleware stack.\nRefer to the figures in the article Express Middlewares, Demystified and Understanding Express Middleware.\nWhen an Express app server receives an HTTP request, it will pass the request to each callback in the middleware stack in order. When a callback calls next(), control will be transferred to the next in the stack. On the other hand, if a callback returns an HTTP response to the client (e.g. by calling res.json()), it will stop the request-response cycle.\nDuring the request-response cycle, a middleware function can make changes to the req or res object, send a response body to complete the processing of the current request, or pass the control to the next callback in the middleware stack. For more information, please refer to the official guide on writing middlewares and using middlewares.\napp.use( (req, res, next) =\u003e { // after logging this request, pass to next  console.log(`${req.method}- ${req.baseUrl}`); next(); }); app.use( (req, res, next) =\u003e { // has this user logged in?  if (!sessionActive) { res.redirect('/login.html'); return; } next(); }); // other routes and middlewares  A useful built-in middleware is express.static. This searches a given directory to find files that match the path in the URL being request. If found, the middleware returns the file as a response. Otherwise, it pass control to the next callback in the middleware stack. express.static is effectively a mini web server.\n// most routes and middlewares should be placed before the static middleware  app.use(express.static(__dirname + '/public')); // if no file matches the request URL, the following routes will be checked.  app.get('special_page.html', (req,res) =\u003e { }); If a file with the same name as a route (e.g. special_page.html) is added to the /public folder, the express.static middleware will stop the request-response cycle, and that route will no longer be used. Therefore, we usually put the static middleware near the bottom of the middleware stack.\nCheck the source code of app4.mjs for demonstration of how to build responses with these methods.\nDownloadable sample code  p550-express.zip - a project containing all example in this page.  ",
    "description": "",
    "tags": null,
    "title": "5-5 Web app server",
    "uri": "/5appserver/5-5/"
  },
  {
    "content": "Motivation Reusing components Suppose you’re developing a web app for online shopping. One page of the app lets the users to input a rating of a product. You’d like to build an interface similar to example p321.html. Wouldn’t it be great if you can utilize some existing code from a third-party library instead of writing this rating feature yourself?\nVue components allow programmers to package some functionality into reusable code, and incorporate the code into their own application with ease. Web app interface typically involves three kinds of code: HTML (the text content and structure), CSS (presentation) and JavaScript (business logic and dynamic behaviour). So Vue components are able to package HTML, CSS and JavaScript codes into a single reusable unit.\nFortunately, there are many UI component library that we can take advantage of in making our web app. And, in fact, we had silently used the Rate component of the component library Element Plus to write example p321.html.\nIn the code snippet from example p321.html, we register our app to use the rate component with components: { ElRate: ElementPlus.ElRate }. In the template, we use the HTML syntax to place the component as in \u003cel-rate v-model=\"value\" :colors=\"colors\"\u003e\u003c/el-rate\u003e. Similar to HTML elements, Vue supports attribute binding, bi-directional binding and event handling on Vue components. (More detail to be covered in coming sections.)\n\u003cdiv id=\"app\"\u003e \u003cspan\u003eRating: {{ value }}\u003c/span\u003e \u003cel-rate v-model=\"value\" :colors=\"colors\"\u003e\u003c/el-rate\u003e \u003c/div\u003e \u003cscript\u003e const opts = { components: { ElRate: ElementPlus.ElRate },  data() { return { value: 3, colors: ['#99A9BF', '#F7BA2A', '#FF9900'] } } }; Vue.createApp(opts).mount('#app'); \u003c/script\u003e Organizing components As web apps become more complicated, putting all the constituent HTML and JavaScript in one large file becomes very difficult to manage and understand. One common technique to tackle this complexity is to decompose the web app interface into a hierarchy of components, as in this diagram.\nAfter decomposition, each component can be stored in a separate file / module. Some of the components can be developed and tested independently, and some may be reused among different pages of the web app, or even among different web apps.\nCommon features of components In this section, we use some components from the ElementPlus Desktop UI library to illustrate common features of Vue components.\nProperties / attributes When you insert a component to a page, you often need to provide value for some properties / attributes to initialize the components. In the following example, property placeholder of \u003cel-input\u003e provides the short message shown in the input box before the user enters any data. When the value is a string literal, you don’t need to use the data-binding syntax v-bind:attr.\nHowever, if the value is other data types (e.g. number, boolean), a data property of the component, or a JavaScript expression, you must use the data-binding syntax.\nData-binding is uni-directional. This means that data is passed into the component in one direction only. If the value changes in the container, Vue will update the component view through reactivity.\nSome components also emit event, and the container can register an event handler with @event. In this example, the \u003cel-button\u003e emits click event, which is handled by a method in the container.\n Bi-directional binding Many input controls in a UI library needs to pass user input to the container. For this purpose, the relevant components usually support v-model to bind a property to a value in the container in both directions. The bound component property can be of different data type. For example, dueDate binds to modelValue in \u003cel-date-picker\u003e, and their data type is Date.\n Internally, bi-directional binding is implemented by the update event. Refer to online reference for more information.\n  Slots Sometimes we need to distribute content to a component. For example, the label on the button \u003cel-button\u003eSwap the two book\u003c/el-button\u003e is put between the start tag and the end tag. The component \u003cel-button\u003e is said to have a slot, and it displays the slot content inside the button.\nThe content passed into a slot is not restricted to string. In general it can contain HTML content and even other components. Consider the \u003cel-row\u003e and \u003cel-col\u003e components for page layout.\nSome components even have more than slots. For example \u003cel-card\u003e has a header slot, in addition to the default slot. Refer to online reference for more information.\n A preview In the next section, we’ll integrate the above examples into a single web app. The dist version of this app is accessible here: c37-feature.\n",
    "description": "",
    "tags": null,
    "title": "3-6 Component: motivation and features",
    "uri": "/3client/3-6/"
  },
  {
    "content": "Object literals In previous sections, we’ve studied how to use JavaScript objects to model complicated data and how to declare functions that can be used as function objects, which can be stored in variable. By combining these knowledge, we can create an object in the sense of Object Oriented Programming: a object with state and behavior.\nTo recap, a JavaScript object is a group of properties. Each property has a name and a value. Previously we create a single object by listing the properties of the object in { }. This is known as object literal.\nlet circle = { x: 2, y: 3, // x, y-coordinate of center of the circle  radius: 5, fillColor: 'red' }; Adding methods A property can take ‘anything’ as value, including number, string, boolean, array, object, and even function. When we add a property with a function value, we’ve added a method to the object.\nlet circle = { x: 2, y: 3, radius: 5, fillColor: 'red', area: function () { return Math.PI * this.radius ** 2 } }; console.log(`Area of the circle is ${circle.area()}`) You call a method of an object with the dot notation (similar to Java). circle.area refers to the function object we defined for the area property. You run this method by adding ( ) (possibly with parameters). In this example, it is circle.area().\nIn the body of a method, this refers to the object on which the method is invoked. (Think ‘area of this circle’)\nThere is a shorthand notation to define methods in an object literal. In this example, we also define another method resize.\nlet circle = { x: 2, y: 3, radius: 5, fillColor: 'red', area() { return Math.PI * this.radius ** 2; }, resize(factor) { this.radius = this.radius * factor; } }; circle.resize(2); console.log(`Area of the circle is ${circle.area()}`); A caveat on writing methods Here is a reminder about writing methods. Never use arrow functions as methods.\nlet circle_with_incorrect_method = { x: 2, y: 3, radius: 5, // arrow functions CANNOT work as methods  area: () =\u003e Math.PI * this.radius ** 2 }; circle_with_incorrect_method.area() // returns NaN The reason that the above example does not work is that when an arrow function is called, it does not set this to refer to the object on which the method is invoked. In this case, this does not point to circle, and this.radius does not exist (or, is undefined).\n Technical note: In this example, this refers to the ‘global object’, which is window in browsers, or globalThis in general. this.radius would refer to a global variable named radius, if it exists.\nSo, how does an arrow function obtain this when invoked? It obtains from the surrounding (usually an outer function). Read this reference for an example.\n Inherited methods You might notice that object literals include some methods not defined by you. For example, point.toString() is called when JavaScript tries to concatenate a string with the object.\nlet point = { x: 2, y: 3 }; console.log('This point is ' + point); The method .toString() is actually inherited from the prototype of the object. But this version of toString is not very informative. You can define a more useful version of toString by redefining it in point.\nlet point = { x: 2, y: 3, toString() { return `(${this.x},${this.y})` } }; console.log(`This point is ${point}`);  JavaScript’s use of prototype to implement inheritance is different from that of Java and Python. You can learn more about that in this reference.\n Exercise   Add a method quadrant() to the object literal point. The method returns the quadrant in which the point resides. (sample answer)\nlet point = { x: -2, y: 3, toString() { return `(${this.x},${this.y})` }, quadrant() { /* your work */ } }; // prints \"The point (-2,3) is in quadrant II\" console.log(`The point ${point}is in quadrant ${point.quadrant()}`);   Write an object literal that implements the queue data structure. Use the following template to write your solution. (sample answer)\nlet q = { // data properties to hold the content of the queue  // ...  enqueue(elem) { // add 'elem' at the end of queue  }, dequeue() { // remove the element at the head of queue, and return the element  }, count() { // returns the number of elements in the queue  }, toString() { // return the content of the queue as string  } }; q.enqueue('a'); q.enqueue('b'); q.enqueue('c'); console.log( q.dequeue() ); // print 'a' console.log( q.count() ); // print 2 q.enqueue('d'); console.log(`The queue contains ${q}.`);   ",
    "description": "",
    "tags": null,
    "title": "2-6 Objects with methods",
    "uri": "/2basic/2-6/"
  },
  {
    "content": "Introduction to Node.js  As we try to build more complicated (client side of) a web app, we’ve to handle a growing number of source code files (including HTML, JavaScript and other assets). We need to break down a large JavaScript program into several modules for better management. We may also want to install and use modules from third-party libraries (e.g. the Element Plus desktop UI library).\nTo handle the complexity of such projects, web developers often apply build tools to facilitate the development and testing processes and automate the building of distributable. In this section, we introduce the Vite tool and demonstrate how to build an Vue project with components and third-party library.\nWe need to have basic understanding of several tools and programming concepts before we dive into the study of Vue components.\nNode and node project From its official page, “Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine”. Node.js is commonly used to develop network services, and, in particular, application servers for web apps (which will be the main topic in chapter 4).\nIn this chapter, we’ll mainly use Node.js as a platform to run development tools of Vue projects. For now, install node from the official page. After installation, check the version as below.\n$ node -v A JavaScript project most likely contains more than one JavaScript files and other resources (e.g. HTML, images) placed in a folder. The folder contains a file package.json which describes the project. You can create package.json with the following steps. See online reference for the meaning of properties in the file.\n$ mkdir proj01 $ cd proj01 $ npm init Now, create a simple JavaScript program hello.js in the project. Run it with the command node hello.js.\n// hello.js console.log(\"Hello Node!\"); Packages and NPM Bundled with Node.js is a package manager called NPM, a command line tool to download (and manage) JavaScript packages from package registry. The default registry is npmjs.com, which has recently become the largest JavaScript registry for both server-side and client-side libraries and also tools written in JavaScript.\nYou can easily install a package into a Node project with the command line tool npm. The following commands installs a toy tool called cowsay locally in the current project, and then run it with the command line tool npx.\n Actually, npx will download a package on-the-fly if it cannot find the package locally. Refer to online reference for more information.\n $ npm install cowsay $ npx cowsay Hello npm! A more useful tool is a simple web server http-server written in JavaScript.\n$ npm install http-server $ npx http-server By default, npm install installs a package and its dependencies in the folder node_modules inside the project folder. Check it out. Moreover, npm install also automatically adds an entry in the package.json.\n{ \"name\": \"proj1\", \"version\": \"1.0.0\", \"scripts\": { \"web\": \"http-server\", \"hello\": \"cowsay \\\"Hello npm script!\\\"\" }, \"dependencies\": { \"cowsay\": \"^1.5.0\", \"http-server\": \"^13.0.1\" } } With the dependencies of a project listed in package.json, you can install all the required package for a project with a simple command in the future.\n$ npm install You can also create scripts in package.json to run commands with npm run. Download the sample package c37-proj01.zip and watch the demo in class.\nVite, a build tool for Vue In the next few sections, we will use a build tool called Vite (official site) to develop, test and build Vue applications.\nUsing a build tool has several advantages, compared to our previous approach of loading JavaScript libraries from CDN and writing JavaScript code in a single *.js file.\n We can manage client-side JavaScript libraries using a package manager (we’ll use npm). A package manager can automatically install dependencies of a package, and take care of versioning of packages. Build tools support loaders and pre-processors, which enable more convenient and powerful formats for programming (e.g. TypeScript). In particular, we’ll use SFC (Single File Component) to group the HTML template, CSS style and JavaScript code of a component into a single file. Build tools can translate JavaScript codes to versions that are compatible with older versions of web browsers. This allows developers to take advantage of modern JavaScript programming constructs (e.g. modules). Module bundlers can trace out the JavaScript codes (function, class) starting from \u003cscript\u003e element in HTML. They can bundle multiple JavaScript files into one (or a few) file, and this can reduce the time that a web browser will load the web application. They support tree shaking, also known as dead code elimination, and will not include in the bundles any code that is not used by the web app.  Project configuration We will use a simple Node project c37-sfc.zip to illustrate how to use Vite to develop a Vue project. First, download the example and expand the zip in a working folder. The following in the package.json of the project.\n{ \"name\": \"c37-sfc\", \"version\": \"0.1.0\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vite build\", \"serve\": \"vite preview\" }, \"dependencies\": { \"vue\": \"^3.2.6\" }, \"devDependencies\": { \"@vitejs/plugin-vue\": \"^1.6.0\", \"@vue/compiler-sfc\": \"^3.2.6\", \"vite\": \"^2.5.2\" } } This project has two kinds of dependencies. dependencies refers to packages that are required by the application itself. Execution of the application requires these packages. In this example, we have only vue 3. But if you use other libraries (e.g. Element Plus), you should install them into the project (e.g. npm install element-plus).\nThe other kind of dependencies is devDependencies. These packages are not necessary while we’re developing the project. You can install packages for development with npm install packageName --save-dev.\nAnother config file in the project is vite.config.js. This configures the Vite build tool. For our purpose, we mostly only need to change the input to the bundler.\nimport { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' export default defineConfig({ plugins: [vue()], build: { rollupOptions: { input: { // list all HTML files that contain Vue components  index: './index.html', }  } } }) Dev server and live-reload The Vue application in this example (c37-sfc.zip) consists of three files. The HTML file is index.html, a browser loads this file to run the web app. The HTML file loads the JavaScript module main.js, which creates a Vue app using createApp(). The root component of the app is provided by a SFC app.vue.\nWe can run a development web server to test the app.\n$ npm run dev Open a browser to connect to the URL that is given by the above command. Can you run the web app?\nVite also supports live reload. When you make some changes to the source code, the browser will reload automatically to show the update. Try to make some changes to the HTML or JavaScript code and see that the browser refreshes to show the up-to-date version of the app.\nBuilding a dist package When you’re reading to deploy the web app to a production web server, you can run npm run build to build an application bundle in the folder dist. Check the content of the folder.\n$ npm run build $ npm run serve Vite also includes a simple web server to test the application bundle. Run npm run serve to start the testing web server.\nA tour of the source code Vite uses ES modules (online reference) to manage the Vue components and other JavaScript files in a project. For example, index.html loads main.js with the following line.\n\u003cdiv id=\"app\"\u003e\u003c/div\u003e \u003c!-- Loading main.js as a JavaScript module --\u003e \u003cscript type=\"module\" src=\"./main.js\"\u003e\u003c/script\u003e main.js sets up the Vue application. The first import statement imports a function createApp from the Vue package previously installed by npm install. The second import statement imports an options object of the root component from a SFC called app.vue. main.js then creates a Vue app according to the options object, and mounts it to the \u003cdiv\u003e with id app in the HTML file.\n// import 'createApp' from the Vue library as a module import { createApp } from \"vue\"; // import the options object from the SFC import opts from \"./app.vue\"; createApp(opts).mount('#app'); Next, let’s look at the content of the SFC file app.vue, which contains the root component of the app. There are three sections in a SFC: the template, the CSS style and the JavaScript code.\nThe template section provides the template code of the component. The JavaScript section exports the options object of the component, which is imported by main.js earlier.\n\u003ctemplate\u003e The time now is \u003cdiv class='clock'\u003e{{ timeNow }}\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { timeNow: undefined } }, created() { this.timeNow = (new Date()).toLocaleTimeString(); setInterval( ()=\u003e{ this.timeNow = (new Date()).toLocaleTimeString(); }, 1000); } }; \u003c/script\u003e \u003cstyle scoped\u003e .clock { padding: 2px; width: 6em; border: 1px solid gray; text-align: center; } \u003c/style\u003e SFC may also include a section for style. SFC allows us to restrict the style rules for this component only with \u003cstyle scoped\u003e.\nUsing third-party components In this section, we go through the source code of another web app, which integrates the three UI component examples in the previous lecture. The link c37-feature provides a deployed version of the web app, which you can run in browser. The source code can be downloaded at c37-feature.\nFirst, notice that package.json adds Element-Plus as dependencies.\n\"dependencies\": { \"element-plus\": \"^1.1.0-beta.8\", \"vue\": \"^3.2.6\" }, This app has four components. The root component app.vue includes three other components, comp01.vue, comp02.vue, comp03.vue. The three child components correspond to the three examples in the previous lecture about common component features. Notice several things in the following listing of app.vue:\n\u003ctemplate\u003e \u003cel-card\u003e \u003ctemplate #header\u003eProperties / Attributes\u003c/template\u003e \u003ccomp-part1\u003e\u003c/comp-part1\u003e \u003c/el-card\u003e  \u003cel-card\u003e \u003ctemplate #header\u003eBi-directional binding\u003c/template\u003e \u003ccomp-part2\u003e\u003c/comp-part2\u003e \u003c/el-card\u003e  \u003cel-card\u003e \u003ctemplate #header\u003eSlots\u003c/template\u003e \u003ccomp-part3\u003e\u003c/comp-part3\u003e \u003c/el-card\u003e  \u003c/template\u003e \u003cscript\u003e import { ElCard } from \"element-plus\"; import 'element-plus/dist/index.css'; import CompPart1 from \"./comp01.vue\"; import CompPart2 from \"./comp02.vue\"; import CompPart3 from \"./comp03.vue\"; export default { components: { ElCard, CompPart1, CompPart2, CompPart3 } }; \u003c/script\u003e  it imports the options object (as default) from the SFC of each child component. The variable name (e.g. CompPart1) is arbitrary, but should follow the Pascal case. it registers the child components in the options object of the root component. (components: { CompPart1 }). Without this, you cannot use the child component in the template. components: { CompPart1 } is a shorthand for components: { CompPart1: CompPart1 }. Because element names in HTML are case-insensitive, Vue will convert the PascalCase CompPart1 to kebab-case comp-part1 in the template. In the template, we inject the child component as \u003ccomp-part1\u003e\u003c/comp-part1\u003e. Since we use one component from the Element Plus library, We also need to import \u003cel-card\u003e from the Node module element-plus, which we has installed earlier using npm install. The Element Plus library comes with a CSS style sheet for setting the appearance of its components. We use the statement import 'element-plus/dist/index.css' to tell Vue to refer to that CSS in the HTML page that includes this component (the root component).  Next, examine the source code of the child component comp01.vue. Similar to the situation in the root component, here, we need to import \u003cel-input\u003e and \u003cel-progress\u003e from element-plus, and register them in this component. We also import the Element-Plus CSS in this SFC because this component is using components from the library. The Vite build tool will only import the CSS once in the HTML page.\n\u003ctemplate\u003e \u003cel-input placeholder=\"what's up?\" suffix-icon=\"el-icon-chat-dot-round\" v-model=\"message\"\u003e\u003c/el-input\u003e \u003cel-progress :text-inside=\"true\" :stroke-width=\"30\" :percentage=\"progress\" :color=\"customColors\"\u003e \u003c/el-progress\u003e \u003cel-button type=\"primary\" @click=\"changeProgress\"\u003eChange progress\u003c/el-button\u003e \u003c/template\u003e \u003cscript\u003e import { ElInput, ElProgress, ElButton } from \"element-plus\"; import 'element-plus/dist/index.css'; export default { components: { ElInput: ElInput, ElProgress: ElProgress, ElButton: ElButton, }, data() { /* omitted */ }, methods: { /* omitted */ } } \u003c/script\u003e \u003cstyle scoped\u003e .el-input, .el-progress { width: 300px; margin: 10px 10px; } \u003c/style\u003e Downloadable sample code  c37-proj01.zip - first sample of Node project c37-sfc.zip - simple Vue app using SFC and Vite build tool c37-feature - a Vue app to integrate the previous examples on common component features. this example demonstrates how to load third-party libraries and how a root component can include child components.  ",
    "description": "",
    "tags": null,
    "title": "3-7 Vue projects and build tools",
    "uri": "/3client/3-7/"
  },
  {
    "content": "A pitfall of object literals If you only need a single object with simple behavior, making an object literal with methods is a quick solution. However, if you need to create and maintain several objects with similar structure (data properties and methods), making separate object literals is cumbersome and inefficient.\nConsider the following example of person health records with a method BMI to calculate Body mass index. We’ll need to define each health record as object with its own version of the BMI method.\nlet p1 = { weight: 70, height: 1.7, BMI() { return this.weight / this.height ** 2 }}; let p2 = { weight: 62, height: 1.4, BMI() { return this.weight / this.height ** 2 }}; // ... Some built-in class On the other hand, the JavaScript language defines several built-in class, each with its own constructor function to create objects of the class. Objects thus created usually have built-in methods as defined in the class. (See the full list of built-in objects in mozilla online reference)\nIn OOP sense, a class defines a template for similar objects, and provides (at least) one constructor function to build new objects belonging to the class.\nDate One common built-in class is Date, which represents a single moment in time. You create a new Date object by calling the constructor new Date(...). All Date object thus created share the same rich list of built-in methods, see [(online reference)].moz-date\n// call a constructor to create a Date object, // which equals to this moment let now = new Date(); // create a Date object for the Macau SAR establishment day let sare = new Date(\"1999-12-20\"); // create a Date object for the coming X'mas let xmas = new Date(2016,11,25); // month: 0-11. Confusing! // a Date object has some methods let now = new Date(); let dow = now.getDay(); // 0-6, where 0 means Sunday console.log(now.toLocaleString()); Array Typically, you construct an array with the array literal syntax like let a = [1, 2, 3]. But because arrays are also JavaScript objects, you can create an Array object by calling the constructor new Array(1,2,3). An array object has many methods, and you can invoke them with the dot notation. Refer to online ref for a list of methods of array objects.\n// same as let a = [1,2,3] let a = new Array(1,2,3); a.unshift(0); a.push(4) for (let odd of a.map(x=\u003ex*2+1)) { console.log(odd); }  Technical note: there is a trap in the design of the Array constructor function when there is only 1 parameter of number type. See reference for detail.\n Map A recent update of JavaScript defines a new kind of collections called Map. A map stores key/value pairs. You create a Map by submitting a list of key/value pairs to the constructor. Each pair is written as an array of two elements, namely key and value. You retrieve an element from a map using a key with the method .get(key). You add / replace an element in the map with the method .set(key,value). You can also delete an element from a map with .delete(key), and check the number of elements with the property .size.\n// creates a new Map with two key/value pairs let m = new Map([ ['one', 1], ['two', 2] ]); // use .get to retrieve an element console.log('one =\u003e ', m.get('one')); // use .set to add / replace an element m.set('three', 3); // now, m is Map {\"one\" =\u003e 1, \"two\" =\u003e 2, \"three\" =\u003e 3} console.log(\"Does the map contains the key 'four'? \", m.has('four')); console.log('No, so .get returns ', m.get('four')); // undefined A map is iterable, and the for .. of loop returns a key/value pair in each step.\nlet m = new Map([ ['one', 1], ['two', 2], ['three', 3] ]); for (let [k,v] of m) { console.log(`k = ${k}v = ${v}`); } Defining class JavaScript has a new syntax to define class. It is similar to the syntax in Java. A class is a template to create similar objects, with a constructor function (which builds new object of the class) and methods (which access properties of the object using this).\nYou typically call the constructor function with new. Inside the constructor, this refers to the new object being created. You should initialize all properties inside the constructor. Notice that in JavaScript, you don’t need to define the properties (as you would define attributes in a Java class).\nIn a method, this refers to the object that invokes the method. Methods defined in a class are available for all objects created using the constructor function.\nclass Point { // create a Point object with the given x-, y- coordinates  constructor (x,y) { // this refers to the new object being built  this.x = x; this.y = y; } // a method to convert the point into a string  toString () { // this refers to the object that invokes the method  return `(${this.x},${this.y})`; } }; let p1 = new Point(3,4); console.log(`p1 is ${p1}`); let p2 = new Point(2,-1); console.log(`p2 is ${p2.toString()}`);  The object created by a constructor is similar to object literal in common usage. (But there are some difference about prototype in implementation detail that we’ll not cover.) Use a class when you need to create many objects using a common template.\n// assume you've run the code listing above // examine the structure of the object created with constructor dir(p1); // and here is an object literal let p3 = { x: 2, y: 5 }; p3.toString = function() { return `(${this.x},${this.y})` } dir(p3);  All properties in JavaScript objects are public. So you can access the properties in a function.\nfunction distanceBetween (p1,p2) { return Math.hypot(p1.x-p2.x, p1.y-p2.y); } function midpoint (p1, p2) { const midx = (p1.x+p2.x)/2; const midy = (p1.y+p2.y)/2; return new Point(midx, midy); } Exercise   Define a class Circle that can be used in the following ways. Hints: the class contains a constructor, a method area to calculate the area of the circle, a method toString to convert the object into string, and a method move(x,y) to move the center of the circle to the given location.\nlet c = new Circle(1,2,10); let a = c.area(); console.log(`The area is ${a}.`); // this calls c.toString() console.log(`c is ${c}`); // c is a circle at (1,2) of radius 10 c.move(-1,0); console.log(`c is ${c}`); // c is a circle at (-1,0) of radius 10   Define a function contains(c1,c2) that takes two Circle objects as parameters and determine whether the first circle contains the second completely. Test your work with the following.\nlet c1 = new Circle(0, 0, 10); let c2 = new Circle(3, 4, 4); let c3 = new Circle(3, 4, 8); console.log('c1 contains c2? ', contains(c1,c2) ); // true console.log('c1 contains c3? ', contains(c1,c3) ); // false   The sample answer is available.\n",
    "description": "",
    "tags": null,
    "title": "2-7 Defining class",
    "uri": "/2basic/2-7/"
  },
  {
    "content": "In this lab, we’ll show how to create a Vue component (StarRate.Vue) and use it in the root component of the web app (App.vue).\nProperties and one-directional binding  We’d like to create a component called \u003cstar-rate\u003e for user to rate something (e.g. products or movie). Take a look at the browser display at the SFC playground for the user interface. The root component App.vue includes the following in its template, and passes values to the \u003cstar-rate\u003e component through the two properties: likes and max-likes.\n\u003c!-- App.vue includes the child component StarRate.vue --\u003e \u003cstar-rate :likes=\"4\" :max-likes=\"7\"\u003e\u003c/star-rate\u003e In StarRate.vue, we define these two properties with the props property in the options object. In this example, the prop likes equals 3, and the prop maxLikes equals 7. Vue will convert the name of the props between kebab-case (in html template) and camelCase (in JavaScript) appropriately. The template can use the props in the same way as data properties. Both work like properties of the view model object.\n// StarRate.vue \u003ctemplate\u003e \u003cspan class=\"divStars\"\u003e \u003cimg v-for=\"n in likes\" :src=\"imgStarOn\"\u003e \u003cimg v-for=\"n in (maxLikes-likes)\" :src=\"imgStarOff\"\u003e \u003c/span\u003e \u003c/template\u003e \u003cscript\u003e export default { props: { likes: Number, maxLikes: Number, },  data() { return { // these two properties contains URLs to two images  imgStarOn, imgStarOff, } } } The code above also demonstrate doing v-for on a range. For example, \u003cspan v-for=\"n in 3\"\u003e{{n}}\u003c/span\u003e will generate three \u003cspan\u003e elements in a sequence: \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e.\nIf a prop is bound to a data property of the container component, and that data property changes, the prop of the child component also change accordingly, and this will cause the child component to refresh its view. Test this in the SFC playground!\nFor more information on defining props in components, please read the online reference.\nBi-directional binding and custom events Passing data into a component through props is one directional. The child component cannot pass updates on the props to the container. In fact, the child component cannot change the value of any prop. In other to inform the container of changes in the child component, we need to define custom events.\nTry the example online at SFC playground for what we want to do: A user can click a star in the \u003cstar-rate\u003e component to change the rating. This component then emits an event to inform the container component.\nTo define the custom events, we list the event names in an array in the emits property of the options object. Later, this component can emit the event using this.$emit(eventName, eventData).\n// StarRate.vue \u003ctemplate\u003e \u003cspan class=\"divStars\"\u003e \u003cimg v-for=\"n in likes\" :src=\"imgStarOn\" @click=\"clickStar(n)\"\u003e \u003cimg v-for=\"n in (maxLikes-likes)\" :src=\"imgStarOff\" @click=\"clickStar(likes+n)\"\u003e  \u003c/span\u003e \u003c/template\u003e \u003cscript\u003e export default { props: { /* omitted for brevity */ }, data() { /* omitted for brevity */ }, emits: [ \"update:likes\" ],  methods: { clickStar(which) { console.log(`click star ${which}`); this.$emit(\"update:likes\", which);  } } } The event name update:likes is a convention in Vue to inform the container component that the child wants to change the value of the prop likes. This event allows us to do bi-directional binding using v-model as in the following.\n\u003cstar-rate v-model:likes=\"current\"\u003e In fact, v-model is a syntactical sugar for updating a prop binding via a custom event. The above is the same as the code below.\n\u003cstar-rate :likes=\"current\" @update:likes=\"current=$event.target.value\"\u003e  Similar, v-model=\"variable\" is the same as :modelValue=\"variable\" @update:modelValue=\"variable=$event.target.value\". If you want to use v-model similar to form controls discussed in 3-5 or as in the UI library ElementPlus, call your prop modelValue.\n Test the bi-directional binding at the example online at SFC playground.\nFor more info about defining custom events in components, please read the online reference.\nDownloadable examples  Version 1 of \u003cstar-rate\u003e component example demonstrates properties and one way binding.  live demo at SFC playground downloadable source code star-comp01.zip   Version 2 of \u003cstar-rate\u003e component example shows custom events and bi-directional binding.  live demo at SFC playground downloadable source code star-comp02.zip   Version 3 includes another custom event and demonstrate data binding to class attribute.  live demo as a deployed web app downloadable source code star-comp.zip    ",
    "description": "",
    "tags": null,
    "title": "3-8 Make your own components",
    "uri": "/3client/3-8/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/"
  }
]
